---
title: "Grafische Darstellungen"
---

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, error= TRUE, comment = NA, options(Encoding="UTF-8"))
```

Bevor Daten statistisch analysiert werden, sollten sie grafisch dargestellt werden, um mögliche Fehler, Ausreißer oder Muster zu erkennen. Darüber hinaus ist die grafische Darstellung der Daten für die Präsentation und Interpretation statistischer Modelle unerlässlich. Wir nutzen hierfür den Datensatz [potato.xlsx](https://github.com/DoreenGabriel/Kurs/blob/main/Themen/03/potato.xlsx){target="_blank"}, wie schon in der vorherigen Kapiteln. Ich füge zusätzlich für die als `character` eingelesenen Spalten, Variablen als Faktoren ein (`variety.f`, `method.f`, `infection.f`) und ändere für `variety.f2` die Reihenfolge der Faktorlevels, i.e. `Unica` ist nun das erste Level.

```{r, message=FALSE}
library(openxlsx)
library(dplyr)
pot<-read.xlsx("potato.xlsx", sheet=1)
pot=pot %>% 
    mutate(variety.f=as.factor(variety),
           method.f=as.factor(method),
           infection.f=as.factor(infection),
           variety.f2=factor(variety, levels=c("Unica" , "Costanera", "Mariva")))
str(pot)
```

# ggplot

Die folgenden Abbildungen werden mit der `library(ggplot2)` erstellt. Einen Schummelzettel zur `library(ggplot2)` findet ihr unter:\
[https://raw.githubusercontent.com/rstudio/cheatsheets/main/translations/german/data-visualization_de.pdf](https://raw.githubusercontent.com/rstudio/cheatsheets/main/translations/german/data-visualization_de.pdf){target="_blank"} Und ein ganzes Buch mit Erklärungen gibt es unter [https://ggplot2-book.org/](https://ggplot2-book.org/){target="_blank"}

Zunächst laden wir die `library(ggplot2)` ein.

```{r, warning=FALSE}
library(ggplot2)
```

Mit der Funktion `ggplot()` geben wir mit `data=pot` den `data.frame` an, in dem sich die Daten befinden und mit dem Argument `aes(x=weight, y=tubers)` die Variablen, die dargestellt werden sollen (aes steht für *aestetics*). Das Ergebnis ist eine Plotoberfläche. Wir können nun verschiedene Layer hinzufügen (z.B. einen Scatterplot) und so bestimmen, wie die Daten dargestellt werden.

```{r}
ggplot(data=pot, aes(x=weight, y=tubers))
```

# Scatterplot `geom_point()`

-   zwei kontinuierliche Variablen
-   `ggplot(data=pot, aes(x=Erklärungsvariable, y=Zielgröße)) + geom_point()`

Mit der Funktion `+ geom_point()` wird ein Scatterplot erzeugt, nachdem in der vorangegangenen Funktion `ggplot()` im Argument `aes(x=, y=)` die Variablen der x- und y-Achse gewählt wurden.

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()
```

## Achsenbeschriftung `labs()`

Mit der Funktion `+ labs(title=" ", x=" ", y=" ")` werden in die " " die Beschriftungen eingefügt.

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  labs(x="Gewicht in g", y="Anzahl Kartoffelknollen")
```

## Achsenlimitierung `coord_cartesian()`

Mit der Funktion `coord_cartesian(xlim=c(,), ylim=c(,))` ändert man das Minimum und Maximum der x- und y-Achse.

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  coord_cartesian(ylim=c(0,15), xlim = c(0,350))
```

## alle Layer über + verbinden

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  labs(x="Gewicht in g", y="Anzahl Kartoffelknollen pro Pflanze")+
  coord_cartesian(ylim=c(0,15), xlim = c(0,350))
```

## Plotsymbol `shape`

Durch das Argument `shape=` in der Funktion `geom_point()` können die Plotsymbole geändert werden. Folgende Symbole werden durch die Zahlen 0 bis 24 abgebildet.

```{r, fig.width=6, fig.height=2.75, echo=FALSE}
shapes <- data.frame(
  shape = c(0:19, 22, 21, 24, 23, 20),
  x = 0:24 %/% 5,
  y = -(0:24 %% 5)
)
ggplot(shapes, aes(x, y)) + 
  geom_point(aes(shape = shape), size = 5, fill = "red") +
  geom_text(aes(label = shape), hjust = 0, nudge_x = 0.15) +
  scale_shape_identity() +
  expand_limits(x = 4.1) +
  scale_x_continuous(NULL, breaks = NULL) + 
  scale_y_continuous(NULL, breaks = NULL)
```

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point(shape=1)
```

## Plotsymbol entsprechend variety

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, shape=variety)) +
  geom_point()
```

## Plotsymbole manuel festlegen

Mit `scale_shape_manual(values=c(1,2,3))` kann man manuell die Plotsymbole verändern, wobei die Werte 1, 2 und 3 dann für die 3 Sorten stehen. Hier kann man ganze Zahlen von 0 bis 24 wählen (siehe Abbildung zu den Plotsymbolen weiter oben). Wichtig ist nur, dass die Anzahl der Zahlen mit der Anzahl der unterschiedlichen Sorten übereinstimmt.

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, shape=variety)) +
  geom_point()+
  scale_shape_manual(values=c(1,2,3))
```

## Größe des Plotsymbols `size`

`size=3` je höher die Zahl, desto größer die Symbole

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point(shape=2, size=3)
```

## Farbe des Plotsymbols `col`

```{r, fig.width=6, fig.height=1, echo=FALSE}
colorsinR <- data.frame(col=1:7, x=1:7, y=1)

ggplot(colorsinR, aes(x, y, fill=factor(col))) + 
  geom_point(size=12, shape=22) +
  geom_text(aes(label = 1:7), hjust = 0, nudge_x = 0.25) +
  scale_fill_manual(values=1:7)+
  expand_limits(x = 7.1) +
  scale_x_continuous(NULL, breaks = NULL) + 
  scale_y_continuous(NULL, breaks = NULL)+
  theme(legend.position="none")
```

Mit `col=3` werden die Symbole grün dargestellt. Farben kann man durch die Zahlen 1 bis 7 wählen oder benennen z.B. "green", "darkgreen", "red". Alle möglichen Farben findet ihr mit der Funktion `colors()`oder auf [http://www.stat.columbia.edu/\~tzheng/files/Rcolor.pdf](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf){target="_blank"}

```{r,echo=T,  fig.width=10, fig.height=10}
library(scales)
show_col(colors()[1:100], ncol=10)
show_col(colors()[152:253], ncol=10)
show_col(pal_hue()(49))
show_col(pal_viridis()(49))
show_col(topo.colors(49))
```

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point(shape=20, size=3, col="#287C8EFF")
```

Auch RGB-Farben können gewählt werden. Hier ein Beispiel für das JKI blau:

-   R: 35
-   G: 80
-   B: 150

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point(shape=20, size=3, col=rgb(35,80,150, max = 255))
```

## Die Farbe des Plotsymbols ensprechend der Faktorausprägung `variety`

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +
  geom_point()
```

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +
  geom_point()+
  scale_color_manual(values=c("royalblue", "orange", "olivedrab"))
```

Die Sorten entsprechend JKI-Farbwelt.

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +
  geom_point()+
  scale_color_manual(values=c(rgb(190,210,35, max = 255), 
                              rgb(35,80,150, max = 255), 
                              rgb(240,215,35, max = 255)))

```

Wenn keine Zuordnung der Werte zu den Farben erfolgt, dann werden die Farben entsprechend der Reihenfolge der Faktorlevels abgebildet (alphanumerisch).

Hier ein Beispiel mit Zuordnung.

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +
  geom_point()+
  scale_color_manual(values=c("Mariva"=rgb(190,210,35, max = 255), 
                              "Unica"=rgb(35,80,150, max = 255), 
                              "Costanera"=rgb(240,215,35, max = 255)))
```

## ein Plot für jede Sorte `facet_grid()` und `facet_wrap()`

Mit der Funktion `+ facet_grid(~ variety)` oder `+ facet_wrap(~ variety)` wird ein separater Plot für jedes Gruppierungslevel der `variety` erzeugt.

```{r, fig.width=6.5}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  facet_grid(~variety)

ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  facet_wrap(~variety)
```

## Ein Plot für jede Sorte und mit und ohne Befall (Infection)

```{r, fig.width=6.5, fig.height=5}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  facet_grid(infection~variety)

ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  facet_wrap(infection~variety, labeller = labeller(.multi_line = FALSE))
```

## Regressionslinien einzeichnen

Im Folgenden sehen wir Beispiele für unterschiedliche Modellfits. Diese dienen nur der Veranschaulichung und ersetzen nicht die statistischen Analysen mit Modelldiagnostik.

### LM fit (lineare Regression)

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  geom_smooth(method=lm)
```

### LM fit ohne Konfidenzintervall

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  geom_smooth(method=lm, se=FALSE)
```

### Polynomial zweiten Grades y= x + x²

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  geom_smooth(method=lm, formula=y ~ poly(x, 2)) # formula=y ~ x+I(x^2)
```

### Polynomial dritten Grades y= x + x² + x³

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  geom_smooth(method=lm, formula=y ~ poly(x, 3)) # formula=y ~ x+I(x^2)+I(x^3)
```

### GLM fit

Wer sich über Generalsierte Lineare Modelle informieren möchte, kann im Intranet unter [http://intranet.julius-kuehn.de/forschungservice/biometrie](http://intranet.julius-kuehn.de/forschungservice/biometrie){target="_blank"} das Skript **Generalisierte Lineare Modelle in R** finden.

#### Zähldaten: Poisson

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  geom_smooth(method=glm, method.args = list(family = "poisson"))
```

#### Zähldaten: Quasipoisson

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  geom_smooth(method=glm, method.args = list(family = "quasipoisson"))
```

#### Zähldaten: Negativbinomial

```{r, warning=FALSE, message=FALSE}
library(MASS)
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  geom_smooth(method="glm.nb")
```

#### Streng positive kontinuierliche Daten: Gamma

```{r}
pot1=pot[pot$weight>0,]
ggplot(data=pot1, aes(x=tubers, y=weight)) +
  geom_point()+
  geom_smooth(method="glm", method.args = list(family = Gamma(link = log)))
```

#### presence/absence: binomial

Wir plotten die Beziehung zwischen Infektion und Luftfeuchtigkeit (`humidity`).

Beispiele mit unterschiedlichen Links (logit, probit und cloglog)

```{r}
#logit
ggplot(data=pot, aes(x=humidity, y=infection)) +
  geom_point()+
  geom_smooth(method="glm", method.args = list(family = binomial))
#probit
ggplot(data=pot, aes(x=humidity, y=infection)) +
  geom_point()+
  geom_smooth(method="glm", method.args = list(family = binomial(link = probit)))
#cloglog
ggplot(data=pot, aes(x=humidity, y=infection)) +
  geom_point()+
  geom_smooth(method="glm", method.args = list(family = binomial(link = cloglog)))
```

### Modellfit für verschiedene Sorten

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, colour=variety)) +
  geom_point()+
  geom_smooth(method=lm)
```

und hier ein Modelfit ohne Berücksichtigung der farblich unterschiedlichen Sorten

```{r}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point(aes(colour=variety))+
  geom_smooth(method=lm)
```

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, colour=variety)) +
  geom_point()+
  geom_smooth(method=lm)+
  facet_grid(~variety)
```

## mögliche Abbildung der Daten

```{r, fig.width=6, fig.height=7}
ggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +
  geom_point()+
  geom_smooth(method=lm)+
  scale_color_manual(values=c(rgb(190,210,35, max = 255), 
                              rgb(35,80,150, max = 255), 
                              rgb(240,215,35, max = 255)))+
  labs(x="Gewicht in g", y="Anzahl Kartoffelknollen")+
  coord_cartesian(ylim=c(0,15), xlim = c(0,350))+
  facet_grid(method~variety)+
  theme(legend.position="bottom")
```

# Übung 3.1.

Die Körpergröße, Schuhgröße, Geschlecht und Augenfarbe von Kursteilnehmer wurde ermittelt. Importiere bitte die Daten [Kursteilnehmer.xlsx](https://github.com/DoreenGabriel/Kurs/blob/main/Themen/03/Kursteilnehmer.xlsx){target="_blank"} in R und benenne den data.frame mit `md`.

::: {.callout-tip collapse="true"}
### Daten einlesen und prüfen

Der Datensatz hat in der ersten Zeile eine detaillierte und in der zweiter Zeile die kurze Variablenbezeichnung. Daher lese ich die Daten mit dem Argument `startRow = 2` erst ab der zweiten Zeile ein.

```{r}
library(openxlsx)
md<-read.xlsx("Kursteilnehmer.xlsx", sheet=1, startRow = 2)
str(md)
```
:::

Lerne folgende Funktionen kennen:

-   `plot(md)`

::: {.callout-tip collapse="true"}
```{r}
plot(md)
```
:::

Plotte:

-   den Zusammenhang zwischen Körpergröße und Schuhgröße mit
    -   unterschiedlichen Farben für die Frauen und Männer und
    -   Regressionslinien

::: {.callout-tip collapse="true"}
```{r}
library(ggplot2)
ggplot(data=md, aes(x=KG, y=SG, colour=G)) +
  geom_point()+
  geom_smooth(method=lm)+
  labs(x="Körpergröße in cm", y="Schuhgröße")

ggplot(data=md, aes(x=KG, y=SG, colour=G)) +
  geom_point()+
  geom_smooth(method=lm)+
  labs(x="Körpergröße in cm", y="Schuhgröße")+
  scale_color_manual(values=c("darkblue", "red"))
```
:::

Zusatzaufgaben:

-   verwende statt geom_point() die Funktion geom_count()

::: {.callout-tip collapse="true"}
```{r}
ggplot(data=md, aes(x=KG, y=SG, colour=G)) +
  geom_count()+
  geom_smooth(method=lm)+
  labs(x="Körpergröße in cm", y="Schuhgröße")+
  scale_color_manual(values=c("darkblue", "red"))
```
:::

-   finde heraus, was mit dem Argument `scales` der Funktion `facet_wrap()` geändert werden kann

::: {.callout-tip collapse="true"}
```{r}
ggplot(data=md, aes(x=KG, y=SG, color=G))+
  geom_count()+
  geom_smooth(method=lm)+
  labs(x="Körpergröße in cm", y="Schuhgröße")+
  scale_color_manual(values=c("darkblue", "red"))+
  facet_wrap(~G)

ggplot(data=md, aes(x=KG, y=SG, color=G))+
  geom_count()+
  geom_smooth(method=lm)+
  labs(x="Körpergröße in cm", y="Schuhgröße")+
  scale_color_manual(values=c("darkblue", "red"))+
  facet_wrap(~G, scales="free_y")

ggplot(data=md, aes(x=KG, y=SG, color=G))+
  geom_count()+
  geom_smooth(method=lm)+
  labs(x="Körpergröße in cm", y="Schuhgröße")+
  scale_color_manual(values=c("darkblue", "red"))+
  facet_wrap(~G, scales="free_x")

ggplot(data=md, aes(x=KG, y=SG, color=G))+
  geom_count()+
  geom_smooth(method=lm)+
  labs(x="Körpergröße in cm", y="Schuhgröße")+
  scale_color_manual(values=c("darkblue", "red"))+
  facet_wrap(~G, scales="free")

```
:::

-   plotte erst Frauen (links) und dann Männer (rechts)

::: {.callout-tip collapse="true"}
Hierfür erstelle ich eine neue Variable `G2` in `md`, die ein Faktor mit den levels w und m ist (statt der alphanumerischen Reihenfolge)

```{r}
md$G2=factor(md$G)
levels(md$G2)
md$G2 <- factor(md$G , levels=c("w", "m"))
levels(md$G2)
table(md$G, md$G2)
```

```{r}
ggplot(data=md, aes(x=KG, y=SG, color=G))+
  geom_count()+geom_smooth(method=lm)+
  facet_wrap(~G2)+
  labs(x="Körpergröße in cm", y="Schuhgröße")+
  scale_color_manual(values=c("darkblue", "red"))
```
:::

Ende Übung 3.1.

------------------------------------------------------------------------

# Boxplot

-   Verteilung einer kontinuierlichen Variable (y) in Relation zu einer kategorialen Variable (x)
-   `ggplot(md, aes(x=Erklärungsvariable, y=Zielgröße)) + geom_boxplot()`\
-   Abgebildet sind:
    -   Median
    -   unteres und oberes Quartil (1. und 3. Quartil = 25 % und 75 % Perzentil)
    -   Whisker (min und max oder 1,5\*Interquantilabstand)
    -   Ausreißer (sind nicht *per se* Ausreißer, aber Punkte außerhalb des 1,5-fachen Interquantilabstandes)
-   geeignet für n \> 10 - 20 pro Kategorie (x)
-   vorsichtige Interpretation für n \> 4 - 10
-   nicht geeignet bei 4 Beobachtungen oder weniger

```{r}
ggplot(data=pot, aes(x=method, y=weight)) +
  geom_boxplot()
```

Wer gerne die Whisker mit einem Querstrich begrenzen möchte, nutzt zusätzlich `stat_boxplot()`.

```{r}
ggplot(data=pot, aes(x=method, y=weight))+ 
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot()
  
```

## jittered Boxplot

Bei einem jittered Boxplot werden die Messwerte zusätzlich über den Boxplot geplottet. Das gibt dem Betrachter ein umfangreicheres Verständnis über die Daten. Um eine überlappung der Daten zu verhindern, wird für jeden Messwert eine kleine Zufallszahl in x-Richtung (`width=0.25`) gezogen. Natürlich werden die Werte nicht in der y-Richtung verändert (`height=0`). Um mögliche Ausreißer nicht doppelt abzubilden, muss das Argument `outlier.shape=NA` in der Funktion `geom_boxplot()` gesetzt werden.

Pallmann & Hothorn 2015: *Boxplots for grouped and clustered data in toxicology. Archives of Toxicology.* DOI 10.1007/s00204-015-1608-4

```{r}
ggplot(data=pot, aes(x=method, y=weight)) +
   stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot(outlier.shape=NA) +
  geom_jitter(width=0.25, height=0, shape=1)
```

## zusätzliche Stats

### Mittelwert

```{r}
ggplot(data=pot, aes(x=method, y=weight)) +
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot(outlier.shape=NA) +
  geom_jitter(width=0.25, height=0, shape=1)+
  stat_summary(fun = "mean", colour = "red", size = 2, geom = "point") # Mittelwert
```

### bootstrapped Konfidenzintervall

```{r}
ggplot(data=pot, aes(x=method, y=weight)) +
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot(outlier.shape=NA) +
  geom_jitter(width=0.25, height=0, shape=1)+
  stat_summary(fun.data = "mean_cl_boot", colour = "red", size = 0.5)
```

### Stichprobenumfang bzw. Anzahl Wiederholungen je Gruppe

[https://stackoverflow.com/questions/42822273/adding-sample-size-to-a-box-plot-at-the-min-or-max-of-the-facet-in-ggplot](https://stackoverflow.com/questions/42822273/adding-sample-size-to-a-box-plot-at-the-min-or-max-of-the-facet-in-ggplot){target="_blank"}

```{r}
give.n<-function(x)
  {
  return(c(y = 300, label = length(x))) # y ggfls. anpassen 
  }

ggplot(data=pot, aes(x=method, y=weight)) +
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot(outlier.shape=NA) +
  geom_jitter(width=0.25, shape=1)+
  stat_summary(fun = "mean", colour = "red", size = 2, geom = "point")+ # Mittelwert
  stat_summary(fun.data = give.n, geom="text", colour="gray10")
```

## weight \~ method und variety

```{r}
# 1)
ggplot(data=pot, aes(x=method, y=weight, colour=variety)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot() 
# 2) 
ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot() 

```

```{r}
# 3) 
ggplot(data=pot, aes(x=method, y=weight)) +
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot() +
  facet_grid(~variety)
```

## x-Achsenlevels

In diesem Beispiel ist die Beschriftung der x-Achsenlevels sehr lang. Mit `\n` können wir einen Zeilenumbruch erzeugen:

```{r}
ggplot(data=pot, aes(x=method, y=weight)) +
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot() +
  facet_grid(~variety)+
  scale_x_discrete(labels =c("aero-\nponic", "bed", "hydro-\nponic", "pot"))
```

oder wir drehen die X-Achsenbeschriftungslevels um 45 Grad.

```{r}
ggplot(data=pot, aes(x=method, y=weight)) +
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot() +
  facet_grid(~variety)+
  scale_x_discrete(labels =c("aeronponic", "bed", "hydronponic", "pot"))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) 
```

## jittered boxplot für weight \~ method und variety

```{r}
ggplot(data=pot, aes(x=method, y=weight, colour=variety)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot(outlier.shape=NA) +
  geom_jitter(shape=1, size=1)
```

Noch nicht ganz richtig. Die Punkte haben zwar unterschiedliche Farben, sind aber nicht den Boxen der Sorten zugeordnet.\
Mit dem Argument `position=position_jitterdodge()` können wir das ändern:

```{r}
ggplot(data=pot, aes(x=method, y=weight, colour=variety)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot(outlier.shape=NA) +
  geom_jitter(position=position_jitterdodge(jitter.width = 0.1, jitter.height = 0, 
                                            dodge.width=0.75), 
              shape=1, size=1)
```

## Transformation der Achsenabstände scale\_.\_()

Häufig weisen Daten eine (Rechts-) Schiefe auf, d.h. es gibt viele kleine und wenige große Werte. Dies ist bei Zähldaten häufig der Fall, die poisson oder negative binomial verteilt sein können oder bei streng positiven diskreten Daten, wie z.B. Biomasse, die gamma-verteilt sein kann. Dabei nimmt die Varianz (die Streuung) häufig mit steigendem Mittelwert zu.

Für die Abbildung solcher Daten eignet sich eine Wurzel- oder Log-Transformation der Achsenabstände durch die die Funktion `scale_y_sqrt()` und `scale_y_log10()`.

Für die Wurzel-Transformation müssen die Werte \>= 0 sein:

```{r}
ggplot(data=pot, aes(x=method, y=weight))+ 
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot()+
  scale_y_sqrt()
```

```{r}
ggplot(data=pot, aes(x=method, y=weight)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot() +
  scale_y_sqrt(limits=c(0,400))
```

Für die logarithmische Skala müssen die Werte \> 0 sein.

```{r}
ggplot(data=pot, aes(x=method, y=weight))+ 
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot()+
  scale_y_log10()
```

In diesem Datensatz sind Nullen enthalten und wir bekommen eine Warnmeldung, dass diese Werte nicht abgebildet werden. Hier hilft folgender Trick:

-   wir addieren eine kleine Konstante `y+1`
-   labeln die Skala bei `y+1` mit den Werten von `y`
-   benennen die Y-Achse `name="weight"`

```{r}
ggplot(data=pot, aes(x=method, y=weight+1))+ 
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot()+
  scale_y_log10(breaks=c(0,3, 10,25, 50, 100,250, 500)+1,
                label=c(0,3, 10, 25, 50, 100,250, 500),
                lim=c(0,500)+1, name="weight")
```

Auch für die wurzeltransformierte Y-Achse können wir die Beschriftung der Achsenticks festlegen. Da wir keine Konstante addiert haben, werden die gleichen Informationen beim Argument `breaks` und `label` eingegeben:

```{r}
ggplot(data=pot, aes(x=method, y=weight))+ 
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot()+
  scale_y_sqrt(breaks=c(0,20, 50, 100, 200, 400), 
               label=c(0,20, 50, 100, 200, 400), 
               lim=c(0,400))
```

```{r}
ggplot(data=pot, aes(x=method, y=weight))+ 
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot()+
  scale_y_sqrt(breaks=seq(0,20, by=5)^2, 
               label=seq(0,20, by=5)^2,
               lim=c(0,400))
```

## Komma statt Punkte in Y-Achse

Wenn wir Abbildungen in Deutsch verfassen, sollten die Dezimalstellen als Komma dargestellt werden.

```{r}
ggplot(data=pot, aes(x=method, y=weight/1000))+ 
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot()+
  scale_y_continuous()
```

Hierfür gibt es die Möglichkeit über das Argument `labels` und die Funktion `number_format()` der `library(scales)` das Dezimalzeichen als Kommas anzeigen zu lassen.

```{r}
ggplot(data=pot, aes(x=method, y=weight/1000))+ 
  stat_boxplot(geom ="errorbar", width = 0.5)+
  geom_boxplot()+
  scale_y_continuous(labels=scales::number_format(accuracy = 0.01, 
                                                  decimal.mark =","))+
  ylab("Gewicht in kg")+
  xlab("Methode")
```

## `facet_grid()` und `facet_wrap()`

### Reihenfolge ändern

Die Reihenfolge der facets (oder auch der Levels im Boxplot) könnt ihr am einfachsten ändern, indem ihr die Reihenfolge der Faktorlevels definiert. Diese werden per default alphanumerisch sortiert. Ich habe nun nach dem Einlesen der Daten den Faktor `variety.f2` mit dem Code `variety.f2=factor(variety, levels=c("Unica" , "Costanera", "Mariva"))` in der Funktion `mutate()` eingepflegt und die Levelreihenfolge geändert. Alternativer Code ohne `mutate()` `pot$variety.f2=factor(pot$variety, levels=c("Unica" , "Costanera", "Mariva"))` Weitere tolle Möglichkeiten, um Fakoren zu manipulieren, bietet die `library(forcats)` [https://forcats.tidyverse.org/](https://forcats.tidyverse.org/){target="_blank"}.

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +
  geom_point()+
  facet_grid(~variety.f2)+
  theme(legend.position="bottom")
```

alternativer Code mit der `library(forcats)` und der Funktion `fct_relevel()`.

```{r}
library(forcats)
pot %>% 
  ggplot(aes(x=weight, y=tubers, color=variety)) +
  geom_point()+
  facet_grid(~fct_relevel(variety, "Unica", "Mariva"))+# hier neue Reihenfolge eingeben
  theme(legend.position="bottom")
```

### labeller = label_both

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +
  geom_point()+
  facet_grid(~variety, labeller = label_both)+
  theme(legend.position="bottom")
```

### labeller = labeller(variety = Sorten.labs)

```{r}
Sorten.labs <- c("a) Costanera", "b) Mariva", "c) Unica")
names(Sorten.labs) <- c("Costanera", "Mariva" ,   "Unica" )

ggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +
  geom_point()+
  facet_grid(~variety, labeller = labeller(variety = Sorten.labs))+
  theme(legend.position="bottom")
```

### Beschriftung im Plot

dabei bilden x und y die Koordinaten im Plot

```{r}
abc=data.frame(label=c("a)", "b)", "c)"), 
               x=c(20,20,20), y=c(13,13, 13),
               variety=c(levels(pot$variety.f)))
abc
```

die Beschrifftung erfolgt dann über die Funktion `geom_text()`

```{r}
ggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +
  geom_point()+
  facet_grid(~variety)+
  geom_text(data  = abc,
            aes(x = x, y = y, label = label), col=1)+
  theme(legend.position="bottom")
```

## Theme

Mit der Funktion \`theme()´ können Gitterlinien, Beschriftungen, Legenden und vieles mehr angepasst werden. [https://ggplot2.tidyverse.org/reference/theme.html](https://ggplot2.tidyverse.org/reference/theme.html){target="_blank"}

```{r}
ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot() +
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(colour = "red", size = rel(1.5)),
        legend.position="top",
        legend.title = element_text(colour="blue", size=10, 
                                      face="bold"))
```

Es gibt eine Reihe von abgestimmten `themes()`:

### theme_bw

white background - weißer Hintergrund und schwarze Gitterlinien

```{r}
ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot() +
  theme_bw()
```

### theme_classic

```{r}
ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot() +
  theme_classic()
```

### theme_pubr

```{r}
library(ggpubr)
ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot() +
  theme_pubr(base_size = 12, border = TRUE)
```

## Farbwahl für fill-Argument

### grey

```{r}
ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot() +
  scale_fill_grey() 
```

### brewer blau

```{r}
ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
  stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.75))+
  geom_boxplot() +
  scale_fill_brewer(palette="Blues")
```

weitere Beispiele [https://ggplot2.tidyverse.org/reference/scale_brewer.html](https://ggplot2.tidyverse.org/reference/scale_brewer.html){target="_blank"}

## Abstand zwischen den Boxen

```{r}
ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
   stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.6))+
  geom_boxplot(position=position_dodge(0.6))

ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
   stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=0.8))+
  geom_boxplot(position=position_dodge(0.8)) 

ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
   stat_boxplot(geom ="errorbar", width = 0.5, position = position_dodge(width=1))+
  geom_boxplot(position=position_dodge(1)) 
```

# Alternative zum Boxplot

## Dotplot

```{r}
ggplot(data=pot, aes(x=method, y=weight, fill=variety)) +
  geom_dotplot(binaxis="y", stackdir="center", binwidth = 5)+
  facet_grid(~variety)+
  theme(legend.position="none", 
        axis.text.x=element_text(angle = 45, hjust = 1))
```

## Violinplot

[http://www.sthda.com/english/wiki/ggplot2-violin-plot-quick-start-guide-r-software-and-data-visualization](http://www.sthda.com/english/wiki/ggplot2-violin-plot-quick-start-guide-r-software-and-data-visualization){target="_blank"}

```{r}
ggplot(data=pot, aes(x=method, y=weight))+ 
  geom_violin()
ggplot(data=pot, aes(x=method, y=weight))+ 
  geom_violin(trim=F)
```

# Übung 3.2.

Plotte:

-   einen Boxplot für Körpergröße in Abhängigkeit von Geschlecht

::: {.callout-tip collapse="true"}
```{r}
ggplot(md, aes(x=G, y=KG, fill=G))+
  stat_boxplot(geom ="errorbar", width = 0.15)+
  geom_boxplot()+
  labs(x="Geschlecht", y="Körpergröße in cm")
```
:::

-   einen Boxplot für Körpergröße in Abhängigkeit von Geschlecht und Augenfarbe

::: {.callout-tip collapse="true"}
```{r}
ggplot(md, aes(x=G, y=KG, fill=AF))+
  stat_boxplot(geom ="errorbar", width = 0.15, position = position_dodge(width=0.75))+
  geom_boxplot()
```

Wir könne den Plot noch schöner gestalten, indem wir die Farben und die Beschriftungen anpassen und die Legende unter den Plot legen.

```{r}
ggplot(md, aes(x=G, y=KG, fill=AF))+
  stat_boxplot(geom ="errorbar", width = 0.15, position = position_dodge(width=0.75))+
  geom_boxplot()+
  labs(x="Geschlecht", y="Körpergröße in cm")+
  scale_fill_manual(values = c("skyblue2", "peachpuff3", "darkseagreen3"), name="Augenfarbe")+
  scale_x_discrete(labels=c("Männer", "Frauen"))+
  theme(legend.position="bottom")

ggplot(md, aes(x=G, y=KG, fill=AF))+
  stat_boxplot(geom ="errorbar", width = 0.15, position = position_dodge(width=0.75))+
  geom_boxplot()+
  labs(x="Geschlecht", y="Körpergröße in cm")+
  scale_fill_manual(values = c("skyblue2", "peachpuff3", "darkseagreen3"), name="Augenfarbe")+
  scale_x_discrete(labels=c("Männer", "Frauen"))+
  facet_wrap(~AF)+
  theme(legend.position="bottom")
```
:::

Zusatzaufgabe:

-   Plotte einen jittered Boxplot von Körpergröße in Relation zum Geschlecht und Augenfarbe

::: {.callout-tip collapse="true"}
## wichtig

Wenn die Beobachtungen als *jittered* Punkte dargestellt werden, muss in `geom_boxplot()` das Argument `outlier.shape=NA` gesetzt werden, damit die *Ausreißer* nicht doppelt erscheinen. Für eine korrekte Zuordnung der Punkte zu den Gruppen muss das Argument `position=position_jitterdodge(jitter.width = 0.1, jitter.height = 0, dodge.width=0.75)` gesetzt werden.

```{r}
ggplot(md, aes(x=G, y=KG, fill=AF))+
  stat_boxplot(geom ="errorbar", width = 0.15, position = position_dodge(width=0.75))+
  geom_boxplot(outlier.shape=NA)+
  geom_jitter(position=position_jitterdodge(jitter.width = 0.05, jitter.height = 0,
                                            dodge.width=0.75),
              shape=1, size=1)+
  labs(x="Geschlecht", y="Körpergröße in cm")+
  scale_fill_manual(values = c("skyblue2", "peachpuff3", "darkseagreen3"), name="Augenfarbe")+
  scale_x_discrete(labels=c("Männer", "Frauen"))+
  theme(legend.position="bottom")

ggplot(md, aes(x=G, y=KG, fill=AF))+
  stat_boxplot(geom ="errorbar", width = 0.15, position = position_dodge(width=0.75))+
  geom_boxplot(outlier.shape=NA)+
  geom_jitter(position=position_jitterdodge(jitter.width = 0.1, jitter.height = 0,
                                            dodge.width=0.75),
              shape=1, size=1)+
  labs(x="Augenfarbe", y="Körpergröße in cm")+
  scale_fill_manual(values = c("skyblue2", "peachpuff3", "darkseagreen3"), name="Augenfarbe")+
  scale_x_discrete(labels=c("Männer", "Frauen"))+
  facet_wrap(~AF)+
  theme(legend.position="bottom")

```
:::

Ende Übung 3.2.

------------------------------------------------------------------------

# Histogramm

zur Darstellung einer kontinuierlichen Variablen

-   Verteilung einer kontinuierlichen Variable
-   Häufigkeitshistogramm, Dichtehistogramm
-   Wertebereich
-   Anzahl Proben im Wertebereich
-   Schiefe der Verteilung

Wir nutzen die Funktion `+ geom_histogram()`

```{r}
ggplot(data=pot, aes(weight)) + 
  geom_histogram()
```

## mit bins und binwidth die Anzahl der Balken (Klassen) ändern

Wir können nun die Anzahl der Klassen mit dem Argument `bins = 15` ändern, oder die Klassenbreite mit `binwidth = 25` wählen.

```{r}
ggplot(data=pot, aes(weight)) + 
  geom_histogram(bins = 15)

ggplot(data=pot, aes(weight)) + 
  geom_histogram(binwidth = 25)
```

## ein Histogramm von weight für die Sorten

Mit der Funktion `+ facet_wrap(~ variety)` oder `+ facet_grid(~ variety)` wird ein separater Plot (hier Histogramm) für jedes Gruppierungslevel der `variety` erzeugt.

```{r, fig.width=6.5}
ggplot(data=pot, aes(weight)) + 
  geom_histogram(binwidth = 25, col=1)+
  facet_wrap(~ variety)
```

# Densityplot

```{r}
ggplot(data=pot, aes(weight)) + 
  geom_density(adjust=.5)
```

```{r, fig.width=7}
ggplot(data=pot, aes(weight, colour=variety, fill=variety)) + 
  geom_density(adjust=.5, alpha=.2)
```

Das Paket `ggridges` bietet tolle Densityplots an.

```{r}
library(ggridges)
ggplot(data=pot, aes(x = weight, y = method, fill = method)) +
  geom_density_ridges_gradient(scale = 3, rel_min_height = 0.01) +
  scale_fill_viridis_d(name = "weigth of method:", option = "D")# Farbschema über Option A bis H 
```

Allerdings wird im Densityplot der Wertebereich weiter dargestellt als beobachtet.

```{r}
ggplot(data=pot, aes(x = weight, y = method, col=method, fill=method)) +
  geom_density_ridges(jittered_points = TRUE,  
                      position = position_points_jitter(width = 0, height = 0.1, yoffset = -0.2),
                      alpha = 0.7, scale = 0.7)+ 
  scale_color_viridis_d(name = "weight of method", option = "D")+
  scale_fill_viridis_d(guide="none")
```

daher können wir auch die Beobachtungen plotten

```{r, fig.height=5, fig.width=8}
ggplot(data=pot, aes(x = weight, y = method, col=method, fill=method)) +
  stat_boxplot(geom ="errorbar", width=0.15, position= position_nudge(y=-.5), col="grey20")+
  geom_boxplot(outlier.shape=NA, width=0.15, position= position_nudge(y=-.5), col="grey20")+
  geom_density_ridges(jittered_points = TRUE, 
                      position = position_points_jitter(width = 0, height = 0.1, yoffset = -0.2),
                      alpha = 0.7, scale = 0.9)+ 
  scale_color_viridis_d(name = "weight", option = "D")+
   scale_fill_viridis_d(guide="none")
```

zusammen mit einen Boxplot.

```{r}
ggplot(pot, aes(x = weight, y = method, fill = method)) +
  stat_boxplot(geom ="errorbar", width=0.15, position= position_nudge(y=-.2), 
               col="grey20", show.legend = FALSE)+
  geom_boxplot(outlier.shape=NA, width=0.15, position= position_nudge(y=-.2), 
               col="grey20",show.legend = FALSE)+
  geom_density_ridges2(aes(point_shape = method), alpha = .5, point_alpha = 1, jittered_points = TRUE) +
  scale_fill_viridis_d()+
  scale_discrete_manual(aesthetics = "point_shape", values = c(21, 22, 23, 24))
```

# Barplot mit zwei Y-Achsen

-   z.B. zur Darstellung von Wetterdaten (Niederschlag und Temperatur)
-   Niederschlag als Balkendiagramm mit Funktion `geom_bar()`
-   Temperatur als Punkte und verbundene Linie mit `geom_line()` und `geom_point()`

```{r}
w=data.frame(Monat=factor(c("Jan", "Feb", "März", "April", "Mai", "Juni", "Juli", "Aug", "Sept", "Okt", "Nov", "Dez"),
             levels=c("Jan", "Feb", "März", "April", "Mai", "Juni", "Juli", "Aug", "Sept", "Okt", "Nov", "Dez")),
             Temp=c(5.0, 6.3, 6.0, 10.7, 12.2, 17.9, 17.5, 20.8, 15.3, 11.6, 7.7, 4.5),
             Nied=c(25.7, 108.3, 37.4, 13.8, 18.9, 43.6, 63.1, 63.0, 48.7, 61.7, 9.9, 35.0))
```

Mit der Funktion `scale_y_continuous` und dem Argument `sec.axis` erzeugen wir eine zweite y-Achse für die Temperatur. In den Funktionen `geom_line()` und `geom_point()` multipliziere ich die Temperatur mit 5, um sie besser in den Plot zu integrieren und verwende dann die Funktion `sec.axis`, um die Skala der zweiten Achse entsprechend anzupassen, i.e. die Werte wieder durch 5 dividieren.

```{r}
ggplot(w, aes(x = Monat)) +
  geom_bar(aes(y = Nied), stat = "identity", fill = "skyblue", alpha = 0.7) +
  geom_line(aes(y = Temp*5 , group = 1), color = "red", linewidth = 1) +
  geom_point(aes(y = Temp*5), color = "red", size = 3) +
  scale_y_continuous(name = "Niederschlag (mm)", breaks=c(0,25,50,75,100),
    sec.axis = sec_axis(~./5, name = "Temperatur (°C)")) +
  labs(title = "Monatlicher Niederschlag und Tagestemperatur in Braunschweig 2020",
       x = "Monat") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Mosaikplot mit `library(vcd)`

-   zur Darstellung von kategorialen Daten
-   Größe der Rechtecke entspricht beobachtete Häufigkeit eines Merkmals
-   Farbe entspricht den Abweichungen zwischen beobachteten und erwarteten Häufigkeiten (Residuen)

[https://cran.r-project.org/web/packages/vcd/vignettes/strucplot.pdf](https://cran.r-project.org/web/packages/vcd/vignettes/strucplot.pdf){target="_blank"}

```{r, message=FALSE, fig.width=6, fig.height=5}
library(vcd)
mosaic(~variety+method+infection, data=pot, shade = TRUE)
mosaic(~variety+infection, data=pot, shade = TRUE)
```

# Layout

## Vier Plots in einer Grafik

Um mehrere Plots in einer Grafik abzubilden, müssen die Plots zunächst einzeln in Objekten gespeichert werden (z.B. `p1` bis `p4`), um dann mit der Funktion `grid.arrange(p1,p2,p3,p4, ncol=2)` der `library(gridExtra)` geplottet zu werden. Mit dem Argument `ncol` kann die Anzahl der Spalten bestimmt werden.

```{r, fig.width=8, fig.height=6}
library(gridExtra)

p1=ggplot(data=pot, aes(weight, colour=method, fill=method)) + 
  geom_density(adjust=.75, alpha=.2)

p2=ggplot(data=pot, aes(x=method, y=weight, colour=method)) +
  geom_boxplot(outlier.shape=NA) +
  geom_jitter(width=0.25, shape=1)

p3=ggplot(data=pot, aes(tubers, colour=method, fill=method)) + 
  geom_density(adjust=.75, alpha=.2)

p4=ggplot(data=pot, aes(x=method, y=tubers, colour=method)) +
  geom_boxplot(outlier.shape=NA) +
  geom_jitter(width=0.25, shape=1)

grid.arrange(p1,p2,p3,p4, ncol=2)
```

Das ist noch nicht wirklich schön. Die Legenden nehmen zu viel Platz ein. Alle Plots haben zudem die gleiche Legende. Diese Redundanz können wir entfernen, indem wir nur im ersten Plot eine Legende zeichnen und dabei diese durch das Argument `theme(legend.position=c(0.8,0.7))` in den Plot zeichnen. Bei den anderen Plots unterdrücken wir durch `theme(legend.position="none")` die Legende.

```{r, fig.width=8, fig.height=7.5}
p1=ggplot(data=pot, aes(weight, colour=method, fill=method)) + 
  geom_density(adjust=.75, alpha=.2)+ 
  theme(legend.position=c(0.8,0.7)) #Legende innerhalb der Plotoberfläche

p2=ggplot(data=pot, aes(x=method, y=weight, colour=method)) +
  geom_boxplot(outlier.shape=NA) +
  geom_jitter(width=0.25, shape=1)+ 
  theme(legend.position="none") #ohne Legende

p3=ggplot(data=pot, aes(tubers, colour=method, fill=method)) + 
  geom_density(adjust=.75, alpha=.2)+ 
  theme(legend.position="none")

p4=ggplot(data=pot, aes(x=method, y=tubers, colour=method)) +
  geom_boxplot(outlier.shape=NA) +
  geom_jitter(width=0.25, shape=1)+ 
  theme(legend.position="none")

grid.arrange(p1,p2,p3,p4, ncol=2)
```

Schon besser.

## Vier Plots in einer Grafik mit einer Legende mit `library(ggpubr)`

Eine weitere Möglichkeit bietet die `library(ggpubr)` mit der Funktion `ggarrange()`. Hier können auch die einzelnen Plots z.B. mit a), b), c) und d) beschriftet werden.

```{r, fig.width=8, fig.height=7.5, message=FALSE}
library(ggpubr)
ggarrange(p1, p2, p3, p4, labels = c("a)", "b)", "c)", "d)"), font.label = list(face="plain"),
          common.legend = TRUE, legend = "bottom")
```

Das Argument `align="hv"` richtet die Plots horizontal und vertikal aus (vgl. a) und c) oben mit dieser Grafik unten).

```{r, fig.width=8, fig.height=7.5, message=FALSE}
ggarrange(p1, p2, p3, p4, labels = c("a)", "b)", "c)", "d)"), font.label = list(face="plain"),
          common.legend = TRUE, legend = "bottom", align="hv")
```

Ausserdem kann auch die relative Breite der Plots geändert werden.

```{r, fig.width=8, fig.height=7.5, message=FALSE}
ggarrange(p1, p2, p3, p4, labels = c("a)", "b)", "c)", "d)"), font.label = list(face="plain"),
          common.legend = TRUE, legend = "bottom", align="hv", widths = c(0.6,0.4))
```

## R-Logo im Plot

```{r}
R_png <- png::readPNG("R_logo.png", native = TRUE)
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  patchwork::inset_element(p = R_png,
                left = 0.01,
                bottom = 0.8,
                right = 0.15,
                top = 0.99)
```

# Abbildung speichern

Alle Abbildungen, die mit `ggplot()` erstellt werden, können als pdf, tiff, jpg, eps usw. im *working directory* gespeichert werden. Zudem kann man über die Argumente die Größe und die Auflösung bestimmen. Das Argument `scale` skaliert die Punkte und Buchstaben relativ zur Plotgröße.

```{r, fig.width=6, fig.height=4.5, eval=FALSE}
ggplot(data=pot, aes(x=weight, y=tubers)) +
  geom_point()+
  labs(x="Gewicht in g", y="Anzahl Kartoffelknollen")
ggsave("plot1.pdf")
ggsave("plot2.pdf", width = 10, height = 8, units = "cm")
ggsave("plot2.1.pdf", width = 10, height = 8, units = "cm", scale=1.3)
ggsave("plot2.2.pdf", width = 10, height = 8, units = "cm", scale=0.7)
ggsave("plot3.tiff", dpi=600, width =10, height = 8, units = "cm", compression="lzw")
```

# Übung 3.3.

Plotte:

-   ein Histogramm von Körpergröße

::: {.callout-tip collapse="true"}
```{r}
ggplot(data=md, aes(KG)) +
  geom_histogram()
```
:::

-   ein Histogramm von Körpergröße getrennt für Frauen und Männer

::: {.callout-tip collapse="true"}
```{r}
ggplot(data=md, aes(KG, fill=G)) +
  geom_histogram(binwidth = 5, col=1)+
  ylab("Anzahl")+
  xlab("Körpergröße in cm")+
  facet_wrap(~ G)+
  labs(fill="Geschlecht")

```
:::

-   Plotte einen Mosaikplot für das Auftreten der Kombinationen aus Augenfarbe und Geschlecht

::: {.callout-tip collapse="true"}
```{r}
library(vcd)
mosaic(~G+AF, data=md, shade = TRUE)
mosaic(~AF+G, data=md, shade = TRUE)
```
:::

Ende Übung 3.3.

------------------------------------------------------------------------
