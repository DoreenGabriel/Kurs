[
  {
    "objectID": "Themen/03/03_Graph.html",
    "href": "Themen/03/03_Graph.html",
    "title": "Grafische Darstellungen",
    "section": "",
    "text": "Bevor Daten statistisch analysiert werden, sollten sie grafisch dargestellt werden, um mögliche Fehler, Ausreißer oder Muster zu erkennen. Darüber hinaus ist die grafische Darstellung der Daten für die Präsentation und Interpretation statistischer Modelle unerlässlich. Wir nutzen hierfür den Datensatz potato.xlsx, wie schon in der vorherigen Kapiteln. Ich füge zusätzlich für die als character eingelesenen Spalten, Variablen als Faktoren ein (variety.f, method.f, infection.f) und ändere für variety.f2 die Reihenfolge der Faktorlevels, i.e. Unica ist nun das erste Level.\nlibrary(openxlsx)\nlibrary(dplyr)\npot&lt;-read.xlsx(\"potato.xlsx\", sheet=1)\npot=pot %&gt;% \n    mutate(variety.f=as.factor(variety),\n           method.f=as.factor(method),\n           infection.f=as.factor(infection),\n           variety.f2=factor(variety, levels=c(\"Unica\" , \"Costanera\", \"Mariva\")))\nstr(pot)\n\n'data.frame':   478 obs. of  11 variables:\n $ variety    : chr  \"Unica\" \"Unica\" \"Unica\" \"Unica\" ...\n $ method     : chr  \"pot\" \"pot\" \"pot\" \"pot\" ...\n $ plant      : num  1 2 3 4 5 6 7 8 9 10 ...\n $ tubers     : num  9 3 4 4 2 2 3 6 9 6 ...\n $ weight     : num  209.9 248.4 53.6 77.2 11.3 ...\n $ infection  : num  0 0 0 0 1 0 0 0 0 0 ...\n $ humidity   : num  26.1 30.2 52.5 34 49.6 ...\n $ variety.f  : Factor w/ 3 levels \"Costanera\",\"Mariva\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ method.f   : Factor w/ 4 levels \"aeroponic\",\"bed\",..: 4 4 4 4 4 4 4 4 4 4 ...\n $ infection.f: Factor w/ 2 levels \"0\",\"1\": 1 1 1 1 2 1 1 1 1 1 ...\n $ variety.f2 : Factor w/ 3 levels \"Unica\",\"Costanera\",..: 1 1 1 1 1 1 1 1 1 1 ..."
  },
  {
    "objectID": "Themen/03/03_Graph.html#achsenbeschriftung-labs",
    "href": "Themen/03/03_Graph.html#achsenbeschriftung-labs",
    "title": "Grafische Darstellungen",
    "section": "Achsenbeschriftung labs()",
    "text": "Achsenbeschriftung labs()\nMit der Funktion + labs(title=\" \", x=\" \", y=\" \") werden in die ” ” die Beschriftungen eingefügt.\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  labs(x=\"Gewicht in g\", y=\"Anzahl Kartoffelknollen\")"
  },
  {
    "objectID": "Themen/03/03_Graph.html#achsenlimitierung-coord_cartesian",
    "href": "Themen/03/03_Graph.html#achsenlimitierung-coord_cartesian",
    "title": "Grafische Darstellungen",
    "section": "Achsenlimitierung coord_cartesian()",
    "text": "Achsenlimitierung coord_cartesian()\nMit der Funktion coord_cartesian(xlim=c(,), ylim=c(,)) ändert man das Minimum und Maximum der x- und y-Achse.\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  coord_cartesian(ylim=c(0,15), xlim = c(0,350))"
  },
  {
    "objectID": "Themen/03/03_Graph.html#alle-layer-über-verbinden",
    "href": "Themen/03/03_Graph.html#alle-layer-über-verbinden",
    "title": "Grafische Darstellungen",
    "section": "alle Layer über + verbinden",
    "text": "alle Layer über + verbinden\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  labs(x=\"Gewicht in g\", y=\"Anzahl Kartoffelknollen pro Pflanze\")+\n  coord_cartesian(ylim=c(0,15), xlim = c(0,350))"
  },
  {
    "objectID": "Themen/03/03_Graph.html#plotsymbol-shape",
    "href": "Themen/03/03_Graph.html#plotsymbol-shape",
    "title": "Grafische Darstellungen",
    "section": "Plotsymbol shape",
    "text": "Plotsymbol shape\nDurch das Argument shape= in der Funktion geom_point() können die Plotsymbole geändert werden. Folgende Symbole werden durch die Zahlen 0 bis 24 abgebildet.\n\n\n\n\n\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point(shape=1)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#plotsymbol-entsprechend-variety",
    "href": "Themen/03/03_Graph.html#plotsymbol-entsprechend-variety",
    "title": "Grafische Darstellungen",
    "section": "Plotsymbol entsprechend variety",
    "text": "Plotsymbol entsprechend variety\n\nggplot(data=pot, aes(x=weight, y=tubers, shape=variety)) +\n  geom_point()"
  },
  {
    "objectID": "Themen/03/03_Graph.html#plotsymbole-manuel-festlegen",
    "href": "Themen/03/03_Graph.html#plotsymbole-manuel-festlegen",
    "title": "Grafische Darstellungen",
    "section": "Plotsymbole manuel festlegen",
    "text": "Plotsymbole manuel festlegen\nMit scale_shape_manual(values=c(1,2,3)) kann man manuell die Plotsymbole verändern, wobei die Werte 1, 2 und 3 dann für die 3 Sorten stehen. Hier kann man ganze Zahlen von 0 bis 24 wählen (siehe Abbildung zu den Plotsymbolen weiter oben). Wichtig ist nur, dass die Anzahl der Zahlen mit der Anzahl der unterschiedlichen Sorten übereinstimmt.\n\nggplot(data=pot, aes(x=weight, y=tubers, shape=variety)) +\n  geom_point()+\n  scale_shape_manual(values=c(1,2,3))"
  },
  {
    "objectID": "Themen/03/03_Graph.html#größe-des-plotsymbols-size",
    "href": "Themen/03/03_Graph.html#größe-des-plotsymbols-size",
    "title": "Grafische Darstellungen",
    "section": "Größe des Plotsymbols size",
    "text": "Größe des Plotsymbols size\nsize=3 je höher die Zahl, desto größer die Symbole\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point(shape=2, size=3)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#farbe-des-plotsymbols-col",
    "href": "Themen/03/03_Graph.html#farbe-des-plotsymbols-col",
    "title": "Grafische Darstellungen",
    "section": "Farbe des Plotsymbols col",
    "text": "Farbe des Plotsymbols col\n\n\n\n\n\nMit col=3 werden die Symbole grün dargestellt. Farben kann man durch die Zahlen 1 bis 7 wählen oder benennen z.B. “green”, “darkgreen”, “red”. Alle möglichen Farben findet ihr mit der Funktion colors()oder auf http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf\n\nlibrary(scales)\nshow_col(colors()[1:100], ncol=10)\n\n\n\nshow_col(colors()[152:253], ncol=10)\n\n\n\nshow_col(pal_hue()(49))\n\n\n\nshow_col(pal_viridis()(49))\n\n\n\nshow_col(topo.colors(49))\n\n\n\n\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point(shape=20, size=3, col=\"#287C8EFF\")\n\n\n\n\nAuch RGB-Farben können gewählt werden. Hier ein Beispiel für das JKI blau:\n\nR: 35\nG: 80\nB: 150\n\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point(shape=20, size=3, col=rgb(35,80,150, max = 255))"
  },
  {
    "objectID": "Themen/03/03_Graph.html#die-farbe-des-plotsymbols-ensprechend-der-faktorausprägung-variety",
    "href": "Themen/03/03_Graph.html#die-farbe-des-plotsymbols-ensprechend-der-faktorausprägung-variety",
    "title": "Grafische Darstellungen",
    "section": "Die Farbe des Plotsymbols ensprechend der Faktorausprägung variety",
    "text": "Die Farbe des Plotsymbols ensprechend der Faktorausprägung variety\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()\n\n\n\n\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  scale_color_manual(values=c(\"royalblue\", \"orange\", \"olivedrab\"))\n\n\n\n\nDie Sorten entsprechend JKI-Farbwelt.\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  scale_color_manual(values=c(rgb(190,210,35, max = 255), \n                              rgb(35,80,150, max = 255), \n                              rgb(240,215,35, max = 255)))\n\n\n\n\nWenn keine Zuordnung der Werte zu den Farben erfolgt, dann werden die Farben entsprechend der Reihenfolge der Faktorlevels abgebildet (alphanumerisch).\nHier ein Beispiel mit Zuordnung.\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  scale_color_manual(values=c(\"Mariva\"=rgb(190,210,35, max = 255), \n                              \"Unica\"=rgb(35,80,150, max = 255), \n                              \"Costanera\"=rgb(240,215,35, max = 255)))"
  },
  {
    "objectID": "Themen/03/03_Graph.html#ein-plot-für-jede-sorte-facet_grid-und-facet_wrap",
    "href": "Themen/03/03_Graph.html#ein-plot-für-jede-sorte-facet_grid-und-facet_wrap",
    "title": "Grafische Darstellungen",
    "section": "ein Plot für jede Sorte facet_grid() und facet_wrap()",
    "text": "ein Plot für jede Sorte facet_grid() und facet_wrap()\nMit der Funktion + facet_grid(~ variety) oder + facet_wrap(~ variety) wird ein separater Plot für jedes Gruppierungslevel der variety erzeugt.\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  facet_grid(~variety)\n\n\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  facet_wrap(~variety)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#ein-plot-für-jede-sorte-und-mit-und-ohne-befall-infection",
    "href": "Themen/03/03_Graph.html#ein-plot-für-jede-sorte-und-mit-und-ohne-befall-infection",
    "title": "Grafische Darstellungen",
    "section": "Ein Plot für jede Sorte und mit und ohne Befall (Infection)",
    "text": "Ein Plot für jede Sorte und mit und ohne Befall (Infection)\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  facet_grid(infection~variety)\n\n\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  facet_wrap(infection~variety, labeller = labeller(.multi_line = FALSE))"
  },
  {
    "objectID": "Themen/03/03_Graph.html#regressionslinien-einzeichnen",
    "href": "Themen/03/03_Graph.html#regressionslinien-einzeichnen",
    "title": "Grafische Darstellungen",
    "section": "Regressionslinien einzeichnen",
    "text": "Regressionslinien einzeichnen\nIm Folgenden sehen wir Beispiele für unterschiedliche Modellfits. Diese dienen nur der Veranschaulichung und ersetzen nicht die statistischen Analysen mit Modelldiagnostik.\n\nLM fit (lineare Regression)\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  geom_smooth(method=lm)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nLM fit ohne Konfidenzintervall\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  geom_smooth(method=lm, se=FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nPolynomial zweiten Grades y= x + x²\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  geom_smooth(method=lm, formula=y ~ poly(x, 2)) # formula=y ~ x+I(x^2)\n\n\n\n\n\n\nPolynomial dritten Grades y= x + x² + x³\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  geom_smooth(method=lm, formula=y ~ poly(x, 3)) # formula=y ~ x+I(x^2)+I(x^3)\n\n\n\n\n\n\nGLM fit\nWer sich über Generalsierte Lineare Modelle informieren möchte, kann im Intranet unter http://intranet.julius-kuehn.de/forschungservice/biometrie das Skript Generalisierte Lineare Modelle in R finden.\n\nZähldaten: Poisson\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  geom_smooth(method=glm, method.args = list(family = \"poisson\"))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nZähldaten: Quasipoisson\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  geom_smooth(method=glm, method.args = list(family = \"quasipoisson\"))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nZähldaten: Negativbinomial\n\nlibrary(MASS)\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  geom_smooth(method=\"glm.nb\")\n\n\n\n\n\n\nStreng positive kontinuierliche Daten: Gamma\n\npot1=pot[pot$weight&gt;0,]\nggplot(data=pot1, aes(x=tubers, y=weight)) +\n  geom_point()+\n  geom_smooth(method=\"glm\", method.args = list(family = Gamma(link = log)))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\npresence/absence: binomial\nWir plotten die Beziehung zwischen Infektion und Luftfeuchtigkeit (humidity).\nBeispiele mit unterschiedlichen Links (logit, probit und cloglog)\n\n#logit\nggplot(data=pot, aes(x=humidity, y=infection)) +\n  geom_point()+\n  geom_smooth(method=\"glm\", method.args = list(family = binomial))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n#probit\nggplot(data=pot, aes(x=humidity, y=infection)) +\n  geom_point()+\n  geom_smooth(method=\"glm\", method.args = list(family = binomial(link = probit)))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n#cloglog\nggplot(data=pot, aes(x=humidity, y=infection)) +\n  geom_point()+\n  geom_smooth(method=\"glm\", method.args = list(family = binomial(link = cloglog)))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nModellfit für verschiedene Sorten\n\nggplot(data=pot, aes(x=weight, y=tubers, colour=variety)) +\n  geom_point()+\n  geom_smooth(method=lm)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nund hier ein Modelfit ohne Berücksichtigung der farblich unterschiedlichen Sorten\n\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point(aes(colour=variety))+\n  geom_smooth(method=lm)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nggplot(data=pot, aes(x=weight, y=tubers, colour=variety)) +\n  geom_point()+\n  geom_smooth(method=lm)+\n  facet_grid(~variety)\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Themen/03/03_Graph.html#mögliche-abbildung-der-daten",
    "href": "Themen/03/03_Graph.html#mögliche-abbildung-der-daten",
    "title": "Grafische Darstellungen",
    "section": "mögliche Abbildung der Daten",
    "text": "mögliche Abbildung der Daten\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  geom_smooth(method=lm)+\n  scale_color_manual(values=c(rgb(190,210,35, max = 255), \n                              rgb(35,80,150, max = 255), \n                              rgb(240,215,35, max = 255)))+\n  labs(x=\"Gewicht in g\", y=\"Anzahl Kartoffelknollen\")+\n  coord_cartesian(ylim=c(0,15), xlim = c(0,350))+\n  facet_grid(method~variety)+\n  theme(legend.position=\"bottom\")\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Themen/03/03_Graph.html#jittered-boxplot",
    "href": "Themen/03/03_Graph.html#jittered-boxplot",
    "title": "Grafische Darstellungen",
    "section": "jittered Boxplot",
    "text": "jittered Boxplot\nBei einem jittered Boxplot werden die Messwerte zusätzlich über den Boxplot geplottet. Das gibt dem Betrachter ein umfangreicheres Verständnis über die Daten. Um eine überlappung der Daten zu verhindern, wird für jeden Messwert eine kleine Zufallszahl in x-Richtung (width=0.25) gezogen. Natürlich werden die Werte nicht in der y-Richtung verändert (height=0). Um mögliche Ausreißer nicht doppelt abzubilden, muss das Argument outlier.shape=NA in der Funktion geom_boxplot() gesetzt werden.\nPallmann & Hothorn 2015: Boxplots for grouped and clustered data in toxicology. Archives of Toxicology. DOI 10.1007/s00204-015-1608-4\n\nggplot(data=pot, aes(x=method, y=weight)) +\n   stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.25, height=0, shape=1)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#zusätzliche-stats",
    "href": "Themen/03/03_Graph.html#zusätzliche-stats",
    "title": "Grafische Darstellungen",
    "section": "zusätzliche Stats",
    "text": "zusätzliche Stats\n\nMittelwert\n\nggplot(data=pot, aes(x=method, y=weight)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.25, height=0, shape=1)+\n  stat_summary(fun = \"mean\", colour = \"red\", size = 2, geom = \"point\") # Mittelwert\n\n\n\n\n\n\nbootstrapped Konfidenzintervall\n\nggplot(data=pot, aes(x=method, y=weight)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.25, height=0, shape=1)+\n  stat_summary(fun.data = \"mean_cl_boot\", colour = \"red\", size = 0.5)\n\n\n\n\n\n\nStichprobenumfang bzw. Anzahl Wiederholungen je Gruppe\nhttps://stackoverflow.com/questions/42822273/adding-sample-size-to-a-box-plot-at-the-min-or-max-of-the-facet-in-ggplot\n\ngive.n&lt;-function(x)\n  {\n  return(c(y = 300, label = length(x))) # y ggfls. anpassen \n  }\n\nggplot(data=pot, aes(x=method, y=weight)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.25, shape=1)+\n  stat_summary(fun = \"mean\", colour = \"red\", size = 2, geom = \"point\")+ # Mittelwert\n  stat_summary(fun.data = give.n, geom=\"text\", colour=\"gray10\")"
  },
  {
    "objectID": "Themen/03/03_Graph.html#weight-method-und-variety",
    "href": "Themen/03/03_Graph.html#weight-method-und-variety",
    "title": "Grafische Darstellungen",
    "section": "weight ~ method und variety",
    "text": "weight ~ method und variety\n\n# 1)\nggplot(data=pot, aes(x=method, y=weight, colour=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot() \n\n\n\n# 2) \nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot() \n\n\n\n\n\n# 3) \nggplot(data=pot, aes(x=method, y=weight)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot() +\n  facet_grid(~variety)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#jittered-boxplot-für-weight-method-und-weight",
    "href": "Themen/03/03_Graph.html#jittered-boxplot-für-weight-method-und-weight",
    "title": "Grafische Darstellungen",
    "section": "jittered boxplot für weight ~ method und weight",
    "text": "jittered boxplot für weight ~ method und weight\n\nggplot(data=pot, aes(x=method, y=weight, colour=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(shape=1, size=1)\n\n\n\n\nNoch nicht ganz richtig. Die Punkte haben zwar unterschiedliche Farben, sind aber nicht den Boxen der Sorten zugeordnet.\nMit dem Argument position=position_jitterdodge() können wir das ändern:\n\nggplot(data=pot, aes(x=method, y=weight, colour=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(position=position_jitterdodge(jitter.width = 0.1, jitter.height = 0, \n                                            dodge.width=0.75), \n              shape=1, size=1)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#transformation-der-achsenabstände-scale_._",
    "href": "Themen/03/03_Graph.html#transformation-der-achsenabstände-scale_._",
    "title": "Grafische Darstellungen",
    "section": "Transformation der Achsenabstände scale_._()",
    "text": "Transformation der Achsenabstände scale_._()\nHäufig weisen Daten eine (Rechts-) Schiefe auf, d.h. es gibt viele kleine und wenige große Werte. Dies ist bei Zähldaten häufig der Fall, die poisson oder negative binomial verteilt sein können oder bei streng positiven diskreten Daten, wie z.B. Biomasse, die gamma-verteilt sein kann. Dabei nimmt die Varianz (die Streuung) häufig mit steigendem Mittelwert zu.\nFür die Abbildung solcher Daten eignet sich eine Wurzel- oder Log-Transformation der Achsenabstände durch die die Funktion scale_y_sqrt() und scale_y_log10().\nFür die Wurzel-Transformation müssen die Werte &gt;= 0 sein:\n\nggplot(data=pot, aes(x=method, y=weight))+ \n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot()+\n  scale_y_sqrt()\n\n\n\n\n\nggplot(data=pot, aes(x=method, y=weight)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot() +\n  scale_y_sqrt(limits=c(0,400))\n\n\n\n\nFür die logarithmische Skala müssen die Werte &gt; 0 sein.\n\nggplot(data=pot, aes(x=method, y=weight))+ \n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot()+\n  scale_y_log10()\n\nWarning in scale_y_log10(): log-10 transformation introduced infinite values.\nlog-10 transformation introduced infinite values.\n\n\nWarning: Removed 8 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\nRemoved 8 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\nIn diesem Datensatz sind Nullen enthalten und wir bekommen eine Warnmeldung, dass diese Werte nicht abgebildet werden. Hier hilft folgender Trick:\n\nwir addieren eine kleine Konstante y+1\nlabeln die Skala bei y+1 mit den Werten von y\nbenennen die Y-Achse name=\"weight\"\n\n\nggplot(data=pot, aes(x=method, y=weight+1))+ \n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot()+\n  scale_y_log10(breaks=c(0,3, 10,25, 50, 100,250, 500)+1,\n                label=c(0,3, 10, 25, 50, 100,250, 500),\n                lim=c(0,500)+1, name=\"weight\")\n\n\n\n\nAuch für die wurzeltransformierte Y-Achse können wir die Beschriftung der Achsenticks festlegen. Da wir keine Konstante addiert haben, werden die gleichen Informationen beim Argument breaks und label eingegeben:\n\nggplot(data=pot, aes(x=method, y=weight))+ \n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot()+\n  scale_y_sqrt(breaks=c(0,20, 50, 100, 200, 400), \n               label=c(0,20, 50, 100, 200, 400), \n               lim=c(0,400))\n\n\n\n\n\nggplot(data=pot, aes(x=method, y=weight))+ \n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot()+\n  scale_y_sqrt(breaks=seq(0,20, by=5)^2, \n               label=seq(0,20, by=5)^2,\n               lim=c(0,400))"
  },
  {
    "objectID": "Themen/03/03_Graph.html#komma-statt-punkte-in-y-achse",
    "href": "Themen/03/03_Graph.html#komma-statt-punkte-in-y-achse",
    "title": "Grafische Darstellungen",
    "section": "Komma statt Punkte in Y-Achse",
    "text": "Komma statt Punkte in Y-Achse\nWenn wir Abbildungen in Deutsch verfassen, sollten die Dezimalstellen als Komma dargestellt werden.\n\nggplot(data=pot, aes(x=method, y=weight/1000))+ \n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot()+\n  scale_y_continuous()\n\n\n\n\nHierfür gibt es die Möglichkeit über das Argument labels und die Funktion number_format() der library(scales) das Dezimalzeichen als Kommas anzeigen zu lassen.\n\nggplot(data=pot, aes(x=method, y=weight/1000))+ \n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot()+\n  scale_y_continuous(labels=scales::number_format(accuracy = 0.01, \n                                                  decimal.mark =\",\"))+\n  ylab(\"Gewicht in kg\")+\n  xlab(\"Methode\")"
  },
  {
    "objectID": "Themen/03/03_Graph.html#theme",
    "href": "Themen/03/03_Graph.html#theme",
    "title": "Grafische Darstellungen",
    "section": "Theme",
    "text": "Theme\nMit der Funktion `theme()´ können Gitterlinien, Beschriftungen, Legenden und vieles mehr angepasst werden. https://ggplot2.tidyverse.org/reference/theme.html\n\nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot() +\n  theme(panel.border = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        axis.text = element_text(colour = \"red\", size = rel(1.5)),\n        legend.position=\"top\",\n        legend.title = element_text(colour=\"blue\", size=10, \n                                      face=\"bold\"))\n\n\n\n\nEs gibt eine Reihe von abgestimmten themes():\n\ntheme_bw\nwhite background - weißer Hintergrund und schwarze Gitterlinien\n\nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot() +\n  theme_bw()\n\n\n\n\n\n\ntheme_classic\n\nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot() +\n  theme_classic()\n\n\n\n\n\n\ntheme_pubr\n\nlibrary(ggpubr)\nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot() +\n  theme_pubr(base_size = 12, border = TRUE)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#farbwahl-für-fill-argument",
    "href": "Themen/03/03_Graph.html#farbwahl-für-fill-argument",
    "title": "Grafische Darstellungen",
    "section": "Farbwahl für fill-Argument",
    "text": "Farbwahl für fill-Argument\n\ngrey\n\nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot() +\n  scale_fill_grey() \n\n\n\n\n\n\nbrewer blau\n\nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot() +\n  scale_fill_brewer(palette=\"Blues\")\n\n\n\n\nweitere Beispiele https://ggplot2.tidyverse.org/reference/scale_brewer.html"
  },
  {
    "objectID": "Themen/03/03_Graph.html#abstand-zwischen-den-boxen",
    "href": "Themen/03/03_Graph.html#abstand-zwischen-den-boxen",
    "title": "Grafische Darstellungen",
    "section": "Abstand zwischen den Boxen",
    "text": "Abstand zwischen den Boxen\n\nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n   stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.6))+\n  geom_boxplot(position=position_dodge(0.6))\n\n\n\nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n   stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.8))+\n  geom_boxplot(position=position_dodge(0.8)) \n\n\n\nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n   stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=1))+\n  geom_boxplot(position=position_dodge(1))"
  },
  {
    "objectID": "Themen/03/03_Graph.html#mit-bins-und-binwidth-die-anzahl-der-balken-klassen-ändern",
    "href": "Themen/03/03_Graph.html#mit-bins-und-binwidth-die-anzahl-der-balken-klassen-ändern",
    "title": "Grafische Darstellungen",
    "section": "mit bins und binwidth die Anzahl der Balken (Klassen) ändern",
    "text": "mit bins und binwidth die Anzahl der Balken (Klassen) ändern\nWir können nun die Anzahl der Klassen mit dem Argument bins = 15 ändern, oder die Klassenbreite mit binwidth = 25 wählen.\n\nggplot(data=pot, aes(weight)) + \n  geom_histogram(bins = 15)\n\n\n\nggplot(data=pot, aes(weight)) + \n  geom_histogram(binwidth = 25)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#ein-histogramm-von-weight-für-die-sorten",
    "href": "Themen/03/03_Graph.html#ein-histogramm-von-weight-für-die-sorten",
    "title": "Grafische Darstellungen",
    "section": "ein Histogramm von weight für die Sorten",
    "text": "ein Histogramm von weight für die Sorten\nMit der Funktion + facet_wrap(~ variety) oder + facet_grid(~ variety) wird ein separater Plot (hier Histogramm) für jedes Gruppierungslevel der variety erzeugt.\n\nggplot(data=pot, aes(weight)) + \n  geom_histogram(binwidth = 25, col=1)+\n  facet_wrap(~ variety)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#vier-plots-in-einer-grafik",
    "href": "Themen/03/03_Graph.html#vier-plots-in-einer-grafik",
    "title": "Grafische Darstellungen",
    "section": "Vier Plots in einer Grafik",
    "text": "Vier Plots in einer Grafik\nUm mehrere Plots in einer Grafik abzubilden, müssen die Plots zunächst einzeln in Objekten gespeichert werden (z.B. p1 bis p4), um dann mit der Funktion grid.arrange(p1,p2,p3,p4, ncol=2) der library(gridExtra) geplottet zu werden. Mit dem Argument ncol kann die Anzahl der Spalten bestimmt werden.\n\nlibrary(gridExtra)\n\n\nAttache Paket: 'gridExtra'\n\n\nDas folgende Objekt ist maskiert 'package:dplyr':\n\n    combine\n\np1=ggplot(data=pot, aes(weight, colour=method, fill=method)) + \n  geom_density(adjust=.75, alpha=.2)\n\np2=ggplot(data=pot, aes(x=method, y=weight, colour=method)) +\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.25, shape=1)\n\np3=ggplot(data=pot, aes(tubers, colour=method, fill=method)) + \n  geom_density(adjust=.75, alpha=.2)\n\np4=ggplot(data=pot, aes(x=method, y=tubers, colour=method)) +\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.25, shape=1)\n\ngrid.arrange(p1,p2,p3,p4, ncol=2)\n\n\n\n\nDas ist noch nicht wirklich schön. Die Legenden nehmen zu viel Platz ein. Alle Plots haben zudem die gleiche Legende. Diese Redundanz können wir entfernen, indem wir nur im ersten Plot eine Legende zeichnen und dabei diese durch das Argument theme(legend.position=c(0.8,0.7)) in den Plot zeichnen. Bei den anderen Plots unterdrücken wir durch theme(legend.position=\"none\") die Legende.\n\np1=ggplot(data=pot, aes(weight, colour=method, fill=method)) + \n  geom_density(adjust=.75, alpha=.2)+ \n  theme(legend.position=c(0.8,0.7)) #Legende innerhalb der Plotoberfläche\n\nWarning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2\n3.5.0.\ni Please use the `legend.position.inside` argument of `theme()` instead.\n\np2=ggplot(data=pot, aes(x=method, y=weight, colour=method)) +\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.25, shape=1)+ \n  theme(legend.position=\"none\") #ohne Legende\n\np3=ggplot(data=pot, aes(tubers, colour=method, fill=method)) + \n  geom_density(adjust=.75, alpha=.2)+ \n  theme(legend.position=\"none\")\n\np4=ggplot(data=pot, aes(x=method, y=tubers, colour=method)) +\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.25, shape=1)+ \n  theme(legend.position=\"none\")\n\ngrid.arrange(p1,p2,p3,p4, ncol=2)\n\n\n\n\nSchon besser."
  },
  {
    "objectID": "Themen/03/03_Graph.html#vier-plots-in-einer-grafik-mit-einer-legende-mit-libraryggpubr",
    "href": "Themen/03/03_Graph.html#vier-plots-in-einer-grafik-mit-einer-legende-mit-libraryggpubr",
    "title": "Grafische Darstellungen",
    "section": "Vier Plots in einer Grafik mit einer Legende mit library(ggpubr)",
    "text": "Vier Plots in einer Grafik mit einer Legende mit library(ggpubr)\nEine weitere Möglichkeit bietet die library(ggpubr) mit der Funktion ggarrange(). Hier können auch die einzelnen Plots z.B. mit a), b), c) und d) beschriftet werden.\n\nlibrary(ggpubr)\nggarrange(p1, p2, p3, p4, labels = c(\"a)\", \"b)\", \"c)\", \"d)\"), font.label = list(face=\"plain\"),\n          common.legend = TRUE, legend = \"bottom\")\n\n\n\n\nDas Argument align=\"hv\" richtet die Plots horizontal und vertikal aus (vgl. a) und c) oben mit dieser Grafik unten).\n\nggarrange(p1, p2, p3, p4, labels = c(\"a)\", \"b)\", \"c)\", \"d)\"), font.label = list(face=\"plain\"),\n          common.legend = TRUE, legend = \"bottom\", align=\"hv\")\n\n\n\n\nAusserdem kann auch die relative Breite der Plots geändert werden.\n\nggarrange(p1, p2, p3, p4, labels = c(\"a)\", \"b)\", \"c)\", \"d)\"), font.label = list(face=\"plain\"),\n          common.legend = TRUE, legend = \"bottom\", align=\"hv\", widths = c(0.6,0.4))"
  },
  {
    "objectID": "Themen/03/03_Graph.html#beschriftung-innerhalb-facet_grid-und-facet_wrap",
    "href": "Themen/03/03_Graph.html#beschriftung-innerhalb-facet_grid-und-facet_wrap",
    "title": "Grafische Darstellungen",
    "section": "Beschriftung innerhalb facet_grid() und facet_wrap()",
    "text": "Beschriftung innerhalb facet_grid() und facet_wrap()\n\nlabeller = label_both\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  facet_grid(~variety, labeller = label_both)+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\n\nlabeller = labeller(variety = Sorten.labs)\n\nSorten.labs &lt;- c(\"a) Costanera\", \"b) Mariva\", \"c) Unica\")\nnames(Sorten.labs) &lt;- c(\"Costanera\", \"Mariva\" ,   \"Unica\" )\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  facet_grid(~variety, labeller = labeller(variety = Sorten.labs))+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\n\nBeschriftung im Plot\ndabei bilden x und y die Koordinaten im Plot\n\nabc=data.frame(label=c(\"a)\", \"b)\", \"c)\"), \n               x=c(20,20,20), y=c(13,13, 13),\n               variety=c(levels(pot$variety.f)))\nabc\n\n  label  x  y   variety\n1    a) 20 13 Costanera\n2    b) 20 13    Mariva\n3    c) 20 13     Unica\n\n\ndie Beschrifftung erfolgt dann über die Funktion geom_text()\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  facet_grid(~variety)+\n  geom_text(data  = abc,\n            aes(x = x, y = y, label = label), col=1)+\n  theme(legend.position=\"bottom\")"
  },
  {
    "objectID": "Themen/03/03_Graph.html#r-logo-im-plot",
    "href": "Themen/03/03_Graph.html#r-logo-im-plot",
    "title": "Grafische Darstellungen",
    "section": "R-Logo im Plot",
    "text": "R-Logo im Plot\n\nR_png &lt;- png::readPNG(\"R_logo.png\", native = TRUE)\nggplot(data=pot, aes(x=weight, y=tubers)) +\n  geom_point()+\n  patchwork::inset_element(p = R_png,\n                left = 0.01,\n                bottom = 0.8,\n                right = 0.15,\n                top = 0.99)"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html",
    "href": "Themen/01/01_Allgemeines.html",
    "title": "Allgemeines",
    "section": "",
    "text": "Diese Bücher sind teilweise etwas älter (was die R-Codes anbetrifft). Sie geben aber trotzdem einen guten Einblick in die Statistik und Anwendung von R.\nCrawley 2013: The R Book. 2nd Edition, E-Book unter http://onlinelibrary.wiley.com/book/10.1002/9781118448908\nCrawley 2013: Statistik mit R.\nDormann 2013: Parametrische Statistik.\nBurnham und Anderson 2002: Model Selection and Multimodel Inference.\nJames, Witten, Hastie & Tibshirani 2023: An Introduction to Statistical Learning with Applications in R. https://hastie.su.domains/ISLR2/ISLRv2_corrected_June_2023.pdf.download.html Hastie, Tibshirani & Friedman 2017: The Elements of Statistical Learning - Data Mining, Inference and Prediction https://hastie.su.domains/ElemStatLearn/printings/ESLII_print12_toc.pdf"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#literatur",
    "href": "Themen/01/01_Allgemeines.html#literatur",
    "title": "Allgemeines",
    "section": "",
    "text": "Diese Bücher sind teilweise etwas älter (was die R-Codes anbetrifft). Sie geben aber trotzdem einen guten Einblick in die Statistik und Anwendung von R.\nCrawley 2013: The R Book. 2nd Edition, E-Book unter http://onlinelibrary.wiley.com/book/10.1002/9781118448908\nCrawley 2013: Statistik mit R.\nDormann 2013: Parametrische Statistik.\nBurnham und Anderson 2002: Model Selection and Multimodel Inference.\nJames, Witten, Hastie & Tibshirani 2023: An Introduction to Statistical Learning with Applications in R. https://hastie.su.domains/ISLR2/ISLRv2_corrected_June_2023.pdf.download.html Hastie, Tibshirani & Friedman 2017: The Elements of Statistical Learning - Data Mining, Inference and Prediction https://hastie.su.domains/ElemStatLearn/printings/ESLII_print12_toc.pdf"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#webseiten",
    "href": "Themen/01/01_Allgemeines.html#webseiten",
    "title": "Allgemeines",
    "section": "Webseiten",
    "text": "Webseiten\n\nKursskripte der vorangegangenen Inhouse-Schulungen sowie der zentralen Biometriekurse des BMEL findet ihr im Intranet http://intranet.julius-kuehn.de/forschungservice/biometrie/?L=0\nviele Tutorien im Netz und auf YouTube\nR Cookbook https://rc2e.com/\nDSFAIR von Paul Schmidt https://schmidtpaul.github.io/dsfair_quarto/\nMailing lists und archives auf http://www.r-project.org/\nhttp://de.wikibooks.org/wiki/GNU_R"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#hilfe-in-r",
    "href": "Themen/01/01_Allgemeines.html#hilfe-in-r",
    "title": "Allgemeines",
    "section": "Hilfe in R",
    "text": "Hilfe in R\n\nhelp.start()\nHilefeseite öffnet sich durch ?Funktion z.B. ?mean\nVergleiche ?mean vs. ??mean"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#pakete-installieren-und-laden",
    "href": "Themen/01/01_Allgemeines.html#pakete-installieren-und-laden",
    "title": "Allgemeines",
    "section": "Pakete installieren und laden",
    "text": "Pakete installieren und laden\n\nentweder im Editor install.packages(\"Paketname\") z.B. install.packages(\"nlme\")\noder über das Fenster Packages/Install und dann Name des Package z.B. nlme eintragen und Install klicken\nLaden der Pakete einmal pro Session durch die Funktion library(\"Paketname\") z.B. library(\"nlme\")"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#grundlagen-programmiersprache-r",
    "href": "Themen/01/01_Allgemeines.html#grundlagen-programmiersprache-r",
    "title": "Allgemeines",
    "section": "Grundlagen Programmiersprache R",
    "text": "Grundlagen Programmiersprache R\n\nR unterscheidet zwischen Groß- und Kleinschreibung\nLeerzeichen werden normalerweise ignoriert, d.h. kein Unterschied 2+5 vs. 2 + 5\nKommentare werden mit # markiert und dadurch nicht als Befehl von R erkannt, sondern als Text\nZeilenumbruch bei langen Befehlen kein Problem (ein + erscheint in der nächsten Zeile)\nNormale Rechenoperationen + - * /\nAchtung ein : bedeutet nicht “geteilt durch”! Probier es aus 10:5\nlog(), log10(), exp(), sqrt(), 2^2, 2^0.5"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#r-ist-objektorientiert",
    "href": "Themen/01/01_Allgemeines.html#r-ist-objektorientiert",
    "title": "Allgemeines",
    "section": "R ist objektorientiert",
    "text": "R ist objektorientiert\n\na &lt;- 5\n\nDie 5 wird dem Objekt a zugewiesen\n\nb &lt;- 3\n\nDie 3 wird dem Objekt b zugewiesen\n\nc &lt;- a + b\n\nc ist die Summe aus a und b.\n\nc\n\n[1] 8"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#datentypen",
    "href": "Themen/01/01_Allgemeines.html#datentypen",
    "title": "Allgemeines",
    "section": "Datentypen",
    "text": "Datentypen\nObjekte können verschieden Datentypen zugehören.\n\nNumeric (Zahl)\nCharacter (Zeichenketten, z.B. “Messeweg”)\nLogical (TRUE, FALSE)\nFactor (Kategoriale Daten mit verschiedenen Levels, z.B. hoch, mittel, niedrig oder rot, blau, gelb)"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#datenstrukturen",
    "href": "Themen/01/01_Allgemeines.html#datenstrukturen",
    "title": "Allgemeines",
    "section": "Datenstrukturen",
    "text": "Datenstrukturen\n\nvector (eindimensionale Vektoren)\nmatrix (zweidimensionale Matrizen)\narray (verallgemeinerte Matrizen mit auch mehr als zwei Dimensionen)\nlist (Listen)\ndata.frame (Datensätze i.e. Tabelle mit unterschiedlichen Datentypen je Spalte)\nfunction (Funktionen)"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#funktionen",
    "href": "Themen/01/01_Allgemeines.html#funktionen",
    "title": "Allgemeines",
    "section": "Funktionen",
    "text": "Funktionen\nBeim Aufruf von Funktionen sind die Werte, die der Funktion als Berechnungsgrundlage dienen, in runde Klammern einzuschließen: z.B.\n\nround(1.358) # runden einer Zahl\n\n[1] 1\n\n\nDie Argumentliste besteht aus Zuweisungen an Argumenten in der Form Argumentname=Wert, die der Funktion die notwendigen Eingangsinformationen liefern.\n\nround(1.358, digits=1)\n\n[1] 1.4\n\nround(1.358, 1)# nur eine Kommastelle\n\n[1] 1.4\n\n\nEs können je nach Funktion ein oder mehrere durch Komma getrennte Argumente angegeben werden, die ihrerseits obligatorisch oder nur optional sein können. Funktionen können ineinander verschachtelt werden z.B.\n\nround(mean(c(3,6,2,8)), digits=1)\n\n[1] 4.8\n\n\nAuf eine Kommastelle gerundeter Mittelwert aus den Zahlen 3, 6, 2 und 8.\nDie Hilfeseite für eine Funktion öffnet sich durch ?round.\n\nBeispiel Funktion seq und rep\n\nseq(from = 2, to = 8, by = 2)\n\n[1] 2 4 6 8\n\nseq(from = 2, to = 8, by= 0.5)\n\n [1] 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0\n\nseq(from = 0, to = 9, length = 4)\n\n[1] 0 3 6 9\n\nrep(1:5, times = 2)\n\n [1] 1 2 3 4 5 1 2 3 4 5\n\nrep(1:5, each = 2)\n\n [1] 1 1 2 2 3 3 4 4 5 5\n\nrep(c(\"A\",\"B\"), times = 2)\n\n[1] \"A\" \"B\" \"A\" \"B\""
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#daten-einlesen",
    "href": "Themen/01/01_Allgemeines.html#daten-einlesen",
    "title": "Allgemeines",
    "section": "Daten einlesen",
    "text": "Daten einlesen\n\nSpaltenbenennung (Variablen) ohne Leerzeichen, keine Zahlen am Anfang, kein + - / % besser _\nkurze, prägnante Variablennamen (Stickstoffduengermenge besser ND), Objektnamen (z.B. für den data.frame Stickstoffversuchsdaten besser ndat) und Pfadnamen (ohne ä, ö & ü)\nMissing Values in Excel leer lassen oder als NA in csv\n\n\nDaten direkt aus Excel einlesen\nDiesen Datensatz potato.xlsx können wir direkt mit der library(openxlsx) aus Excel einlesen.\n\n\nlibrary(openxlsx)\nmd&lt;-read.xlsx(\"potato.xlsx\", sheet=1)\nstr(md)\n\n'data.frame':   478 obs. of  7 variables:\n $ variety  : chr  \"Unica\" \"Unica\" \"Unica\" \"Unica\" ...\n $ method   : chr  \"pot\" \"pot\" \"pot\" \"pot\" ...\n $ plant    : num  1 2 3 4 5 6 7 8 9 10 ...\n $ tubers   : num  9 3 4 4 2 2 3 6 9 6 ...\n $ weight   : num  209.9 248.4 53.6 77.2 11.3 ...\n $ infection: num  0 0 0 0 1 0 0 0 0 0 ...\n $ humidity : num  26.1 30.2 52.5 34 49.6 ...\n\n# oder\nmd&lt;-read.xlsx(\"potato.xlsx\", sheet=\"Tabelle1\")\n\nSolltet ihr mit RMarkdown arbeiten, dann werden die Daten (ohne Pfadangabe) aus dem Ordner in dem auch das .Rmd gespeichert ist eingelesen.\n\nalternativ könnt ihr den Pfad angeben:\n\n\n# entweder\nmd&lt;-read.xlsx(\"D:/R/Kartoffelversuch/potato.xlsx\", sheet=1)\n# oder\nmd&lt;-read.xlsx(\"D:\\\\R\\\\Kartoffelversuch\\\\potato.xlsx\", sheet=1)\n\noder\n\nihr setzt das working directory\n\nund lest dann die Daten ohne Angabe des Pfades ein\n\n\nsetwd(\"D:/R/Kartoffelversuch\") \nmd&lt;-read.xlsx(\"potato.xlsx\", sheet=1)\n\nÜber das Argument startRow können Zeilen übersprungen werden. Wenn bspw. die erste Zeile die ausführliche Beschreibung der Spalteninformation enthält und erst in der zweiten Zeile die kurzen prägnanten Variablennamen stehen, dann kann mit startRow=2 der Datensatz ab Zeile 2 eingelesen werden.\n\n\nmd&lt;-read.xlsx(\"potato_Zeile_2.xlsx\", sheet=1, startRow=2)\nstr(md)\n\n'data.frame':   478 obs. of  6 variables:\n $ variety  : chr  \"Unica\" \"Unica\" \"Unica\" \"Unica\" ...\n $ method   : chr  \"pot\" \"pot\" \"pot\" \"pot\" ...\n $ plant    : num  1 2 3 4 5 6 7 8 9 10 ...\n $ tubers   : num  9 3 4 4 2 2 3 6 9 6 ...\n $ weight   : num  209.9 248.4 53.6 77.2 11.3 ...\n $ infection: num  0 0 0 0 1 0 0 0 0 0 ...\n\n\nMissing values in Excel leer lassen. R zeigt diese missing values als NA an. \n\nmd2&lt;-read.xlsx(\"potato_NA.xlsx\", sheet=1)\nhead(md2)# zeigt die ersten 6 Zeilen an\n\n  variety method plant tubers weight infection\n1   Unica    pot     1      9  209.9         0\n2   Unica    pot     2      3  248.4         0\n3   Unica    pot     3      4     NA         0\n4   Unica    pot     4      4   77.2         0\n5   Unica    pot     5      2   11.3         1\n6   Unica    pot     6      2   17.8         0\n\n\n\n\nals .csv\n\nin Excel ein Tabellenblatt als .csv oder .txt speichern\nfunktion read.table für .txt oder read.csv für .csv mit den Argumenten:\n\nheader=TRUE bedeutet, dass in der ersten Zeile die Variablenbezeichnungen stehen\nsep ist der Separator, kann Komma, Semikolon oder Tab sein\ndec ist das Dezimalzeichen, kann Komma oder Punkt sein\nread.csv() für englische Excel-Einstellungen\nread.csv2() für deutsche Excel-Einstellungen.\n\n\n\nmd&lt;-read.csv2(\"potato.csv\", header=TRUE)\n# wenn csv unter englischen Excel-Einstellungen gespeichert wurde\nmd&lt;- read.csv(\"potato.csv\", header = TRUE, sep = \",\", dec = \".\")  \n# wenn csv unter deutschen Excel-Einstellungen gespeichert wurde\nmd&lt;- read.csv2(\"potato.csv\", header = TRUE, sep = \";\", dec = \",\") \n\n\n\nals .txt\n\nmd&lt;- read.table(\"potato.txt\", header = TRUE, sep = \"\", dec = \".\")\n\n\n\nDateneinlesen in R-Studio per Klick\nEine weitere Alternative bietet R-Studio auf Environment/Import Dataset. Hier kann man sich durchklicken, um Daten zu importieren. Man sollte aber unbedingt den R-Code nach erfolgtem Import ins Skript kopieren, damit man ihn in der nächsten Sitzung ausführen kann. So behält man den Überblick, welche Daten zur Analyse genutzt wurden. Außerdem können nur so auch Dritte den Import der Daten nachvollziehen. Stichwort reproducible research.\nDer Datenimport aus anderen Statistikprogrammen (SPSS, Stata, SAS) ist mit dem Package foreign oder aus Datenbanken mit dem Package RODBC möglich."
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#datenstruktur-prüfen",
    "href": "Themen/01/01_Allgemeines.html#datenstruktur-prüfen",
    "title": "Allgemeines",
    "section": "Datenstruktur prüfen",
    "text": "Datenstruktur prüfen\nNach erfolgtem Import sollte immer die Struktur der Daten durch die Funktion str() z.B. str(md) überprüft werden.\n\nstr(md)\n\n'data.frame':   478 obs. of  6 variables:\n $ variety  : chr  \"Unica\" \"Unica\" \"Unica\" \"Unica\" ...\n $ method   : chr  \"pot\" \"pot\" \"pot\" \"pot\" ...\n $ plant    : num  1 2 3 4 5 6 7 8 9 10 ...\n $ tubers   : num  9 3 4 4 2 2 3 6 9 6 ...\n $ weight   : num  209.9 248.4 53.6 77.2 11.3 ...\n $ infection: num  0 0 0 0 1 0 0 0 0 0 ...\n\n\nWir sehen hier, dass die Sorte und Methode als Character eingelesen wurde und alle anderen Spalten numerisch sind. Schaut bitte zum Kapitel [Beispieldatensatz potato.xlsx], wie Character in Faktoren umgewandelt werden.\nMit den Funktionen head()und tail() lässt man sich die ersten und letzten 6 Zeilen des Datensatzes anzeigen.\n\nhead(md)\n\n  variety method plant tubers weight infection\n1   Unica    pot     1      9  209.9         0\n2   Unica    pot     2      3  248.4         0\n3   Unica    pot     3      4   53.6         0\n4   Unica    pot     4      4   77.2         0\n5   Unica    pot     5      2   11.3         1\n6   Unica    pot     6      2   17.8         0\n\ntail(md)\n\n      variety    method plant tubers weight infection\n473 Costanera aeroponic     5      7   22.7         0\n474 Costanera aeroponic     6      5   38.4         1\n475 Costanera aeroponic     7      3   28.4         0\n476 Costanera aeroponic     8      6   29.1         1\n477 Costanera aeroponic     9      4   17.6         0\n478 Costanera aeroponic    10      7   36.9         0"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#datenexport",
    "href": "Themen/01/01_Allgemeines.html#datenexport",
    "title": "Allgemeines",
    "section": "Datenexport",
    "text": "Datenexport\nWir können die Daten exportieren.\n\nmit dem Package openxlsx:\n\n\nlibrary(openxlsx)\nwrite.xlsx(md, \"potato.export2.xlsx\")\n\nDas Package openxlsx bietet die Möglichkeit, unterschiedliche Datensätze in mehreren Tabellenblättern in einer xlsx-Datei zu speichern. Hier mal exemplarisch, indem wir den potato-Datensatz mit einer summary statistics (siehe Kapitel Deskriptive Statistik) in zwei Tabellenblättern in einer Datei speichern.\n\nlibrary(dplyr)\nmd.sum=md %&gt;% group_by(variety, method) %&gt;% \n  summarise(weight_avg=mean(weight, na.rm = TRUE),\n            weight_sd=sd(weight, na.rm = TRUE))\nmd.sum\n\n# A tibble: 12 x 4\n# Groups:   variety [3]\n   variety   method     weight_avg weight_sd\n   &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1 Costanera aeroponic        40.2     16.6 \n 2 Costanera bed              87.5     32.6 \n 3 Costanera hydroponic       25.1      8.17\n 4 Costanera pot             141.      22.2 \n 5 Mariva    aeroponic        95.4     54.8 \n 6 Mariva    bed              96.8     54.8 \n 7 Mariva    hydroponic       14.3      9.34\n 8 Mariva    pot              92.2     27.4 \n 9 Unica     aeroponic        88.5     70.8 \n10 Unica     bed              69.1     36.4 \n11 Unica     hydroponic       26.3     14.1 \n12 Unica     pot              94.6     60.3 \n\n\n\nwb &lt;- createWorkbook()\naddWorksheet(wb, sheetName = \"Kartoffeldaten\")\nwriteData(wb, \"Kartoffeldaten\", md) \naddWorksheet(wb, sheetName = \"summary statistics\")\nwriteData(wb, \"summary statistics\", md.sum) \nsaveWorkbook(wb, file = \"potato.export3.xlsx\", overwrite = TRUE)"
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#datenformat",
    "href": "Themen/01/01_Allgemeines.html#datenformat",
    "title": "Allgemeines",
    "section": "Datenformat",
    "text": "Datenformat\nDas flat format ist gegenüber dem wide format zu bevorzugen.\nBsp. flat format\n\n\n\nBehandl\nErtrag\n\n\n\n\nN0\n3.5\n\n\nN0\n1.5\n\n\nN0\n2.8\n\n\nN0\n3.1\n\n\nN100\n6.4\n\n\nN100\n7.4\n\n\nN100\n5.8\n\n\nN100\n5.4\n\n\nN200\n5.9\n\n\nN200\n8.4\n\n\nN200\n7.7\n\n\nN200\n6.7\n\n\n\nBsp. wide format\n\n\n\nKontrolle\nN-Level 100\nN-Level 200\n\n\n\n\n3.5\n6.4\n5.9\n\n\n1.5\n7.4\n8.4\n\n\n2.8\n5.8\n7.7\n\n\n3.1\n5.4\n6.7\n\n\n\nR kann vom wide zum flat format (und zurück) konvertieren, z.B. mit der Funktion melt aus der library(reshape2). Siehe auch http://www.cookbook-r.com/Manipulating_data/Converting_data_between_wide_and_long_format/."
  },
  {
    "objectID": "Themen/01/01_Allgemeines.html#übung-1",
    "href": "Themen/01/01_Allgemeines.html#übung-1",
    "title": "Allgemeines",
    "section": "Übung 1",
    "text": "Übung 1\nDie Körpergröße, Schuhgröße, Geschlecht und Augenfarbe von Kursteilnehmer wurde ermittelt. Importiere bitte die Daten Kursteilnehmer.xlsx in R und benenne den data.frame mit md.\nLernt die Daten und folgende Funktionen kennen:\n\nstr(md)\nnames(md)\nhead(md)\ntail(md)\nmd[,]\nmd[1,]\nmd[,3]\nmd[,-3]\nmd[1:3,]\nmd[,1:3]\n\nmd[2,2:4]\nmd[,c(2,4)]\n\nEnde Übung 1"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Über diese Webseite",
    "section": "",
    "text": "Diese Webseite ist die Grundlage für meinen Kurs “Einführung in R”, den ich für Wissenschaftler am JKI gebe. Sie soll den Einstieg in die Arbeit mit R erleichtern und anhand von Beispielen Lösungswege und -möglichkeiten für häufig auftretende statistische Fragestellungen aufzeigen. Sie ist als eine Art Kochbuch zu verstehen. Man kann die Rezepte verwenden und selbst kreativ werden.\nDer Inhalt wird kontinuierlich aktualisiert und erweitert.\nBei Fragen und Anmerkungen kontaktiert mich bitte: doreen.gabriel@julius-kuehn.de"
  },
  {
    "objectID": "Themen/02/02_DeskriptiveStats.html",
    "href": "Themen/02/02_DeskriptiveStats.html",
    "title": "Datenmanagement und deskriptive Statistik",
    "section": "",
    "text": "Diese Daten sind die leicht modifizierten und erweiterten greenhouse-Daten aus dem R-Paket agricolae.\nIn einem Versuch wurden verschiedene Kartoffelsorten (variety) in verschiedenen Anbaumethoden (method) kultiviert und die Anzahl Knollen (tubers), deren Gewicht (weight), der Krankheitsbefall (infection 1=ja, 0=nein) und die mittlere Luftfeuchte (humidity) ermittelt.\nZunächst lesen wir den Datensatz potato.xlsx mit der Funktion read.xlsx aus der library(openxlsx) ein und benennen den data.frame mit pot und machen uns mit ihm vertraut.\n\nlibrary(openxlsx)\npot&lt;-read.xlsx(\"potato.xlsx\", sheet=1)\nstr(pot)\n\n'data.frame':   478 obs. of  7 variables:\n $ variety  : chr  \"Unica\" \"Unica\" \"Unica\" \"Unica\" ...\n $ method   : chr  \"pot\" \"pot\" \"pot\" \"pot\" ...\n $ plant    : num  1 2 3 4 5 6 7 8 9 10 ...\n $ tubers   : num  9 3 4 4 2 2 3 6 9 6 ...\n $ weight   : num  209.9 248.4 53.6 77.2 11.3 ...\n $ infection: num  0 0 0 0 1 0 0 0 0 0 ...\n $ humidity : num  26.1 30.2 52.5 34 49.6 ...\n\n\nDer Datensatz hat 478 Zeilen (Beobachtungen) und 7 Spalten.\nvariety undmethod sind als character eingelesen.\n\nunique(pot$variety)\n\n[1] \"Unica\"     \"Mariva\"    \"Costanera\"\n\nunique(pot$method)\n\n[1] \"pot\"        \"bed\"        \"hydroponic\" \"aeroponic\" \n\n\nDiese können wir auch in Faktoren umwandeln (siehe Section 2.2.3.1). Alle anderen Variablen sind numerisch."
  },
  {
    "objectID": "Themen/02/02_DeskriptiveStats.html#zeilen",
    "href": "Themen/02/02_DeskriptiveStats.html#zeilen",
    "title": "Datenmanagement und deskriptive Statistik",
    "section": "Zeilen",
    "text": "Zeilen\nWir lernen nun Funtionen aus dem paket dplyr kennen, mit denen wir Beobachtungen, d.h. Zeilen unseres Datensatzes, auswählen oder umsortieren können.\n\nfilter\nMit der Funktion filter können wir ein Subset des Datensatzes erstellen. pot.M enthält mit folgendem Code nur noch Beobachtungen der Sorte Mariva.\n\npot.M&lt;- pot.sub %&gt;% filter(variety==\"Mariva\")\npot.M\n\n# A tibble: 8 x 7\n# Groups:   variety, method [4]\n  variety method     plant tubers weight infection humidity\n  &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 Mariva  aeroponic      7      6  99.2          0     31.8\n2 Mariva  aeroponic      5      5  72.6          0     24.5\n3 Mariva  bed            7      5  59.9          0     56.3\n4 Mariva  bed            8      5  77.3          0     16.3\n5 Mariva  hydroponic     9      2  10.8          0     44.6\n6 Mariva  hydroponic     9      1   7.85         0     48.5\n7 Mariva  pot            5      7 104.           0     41.4\n8 Mariva  pot            8      5  64.8          0     27.3\n\n\npot.BM enthält mit folgendem Code nur noch Beobachtungen der Sorte Mariva und Methode bed.\n\npot.MB&lt;- pot.sub %&gt;% filter(variety==\"Mariva\", method==\"bed\")\npot.MB  \n\n# A tibble: 2 x 7\n# Groups:   variety, method [1]\n  variety method plant tubers weight infection humidity\n  &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 Mariva  bed        7      5   59.9         0     56.3\n2 Mariva  bed        8      5   77.3         0     16.3\n\n\nMehrere Ausprägungen einer Variable können mit %in% ausgewählt werden: pot.MU enthält mit folgendem Code nur noch Beobachtungen der Sorten Mariva und Unica.\n\npot.MU&lt;- pot.sub %&gt;% filter(variety%in%c(\"Mariva\", \"Unica\"))\npot.MU\n\n# A tibble: 16 x 7\n# Groups:   variety, method [8]\n   variety method     plant tubers weight infection humidity\n   &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1 Mariva  aeroponic      7      6  99.2          0     31.8\n 2 Mariva  aeroponic      5      5  72.6          0     24.5\n 3 Mariva  bed            7      5  59.9          0     56.3\n 4 Mariva  bed            8      5  77.3          0     16.3\n 5 Mariva  hydroponic     9      2  10.8          0     44.6\n 6 Mariva  hydroponic     9      1   7.85         0     48.5\n 7 Mariva  pot            5      7 104.           0     41.4\n 8 Mariva  pot            8      5  64.8          0     27.3\n 9 Unica   aeroponic      6      2 112.           0     27.5\n10 Unica   aeroponic      7      4  50.1          0     40.0\n11 Unica   bed            9      4 124.           0     41.8\n12 Unica   bed            9      3  38            0     56.8\n13 Unica   hydroponic     6      2  17.1          0     50.2\n14 Unica   hydroponic     4      2  21.8          0     14.3\n15 Unica   pot            7      4  50.4          0     36.0\n16 Unica   pot            9      5  97.7          1     58.7\n\n\nAlternativ können alle Beobachtungen bis auf Sorte Mariva selektiert werden.\n\npot.oM&lt;- pot.sub %&gt;% filter(variety!=(\"Mariva\"))\npot.oM \n\n# A tibble: 16 x 7\n# Groups:   variety, method [8]\n   variety   method     plant tubers weight infection humidity\n   &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1 Costanera aeroponic      1      5   24.1         0     33.9\n 2 Costanera aeroponic      5      7   42           0     26.0\n 3 Costanera bed            4      7  137.          1     41.6\n 4 Costanera bed            3      5   78           1     51.0\n 5 Costanera hydroponic     8      6   31.8         1     57.2\n 6 Costanera hydroponic     4      5   42           1     56.8\n 7 Costanera pot            5      3  110.          0     26.6\n 8 Costanera pot            6      7  139.          0     41.6\n 9 Unica     aeroponic      6      2  112.          0     27.5\n10 Unica     aeroponic      7      4   50.1         0     40.0\n11 Unica     bed            9      4  124.          0     41.8\n12 Unica     bed            9      3   38           0     56.8\n13 Unica     hydroponic     6      2   17.1         0     50.2\n14 Unica     hydroponic     4      2   21.8         0     14.3\n15 Unica     pot            7      4   50.4         0     36.0\n16 Unica     pot            9      5   97.7         1     58.7\n\n\nHier werden alle Beobachtungen mit größer gleich 5 Knollen selektiert.\n\npot.T5 &lt;-pot.sub %&gt;% filter(tubers&gt;=5)\npot.T5\n\n# A tibble: 14 x 7\n# Groups:   variety, method [8]\n   variety   method     plant tubers weight infection humidity\n   &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1 Costanera aeroponic      1      5   24.1         0     33.9\n 2 Costanera aeroponic      5      7   42           0     26.0\n 3 Costanera bed            4      7  137.          1     41.6\n 4 Costanera bed            3      5   78           1     51.0\n 5 Costanera hydroponic     8      6   31.8         1     57.2\n 6 Costanera hydroponic     4      5   42           1     56.8\n 7 Costanera pot            6      7  139.          0     41.6\n 8 Mariva    aeroponic      7      6   99.2         0     31.8\n 9 Mariva    aeroponic      5      5   72.6         0     24.5\n10 Mariva    bed            7      5   59.9         0     56.3\n11 Mariva    bed            8      5   77.3         0     16.3\n12 Mariva    pot            5      7  104.          0     41.4\n13 Mariva    pot            8      5   64.8         0     27.3\n14 Unica     pot            9      5   97.7         1     58.7\n\npot.T5$tubers\n\n [1] 5 7 7 5 6 5 7 6 5 5 5 7 5 5\n\n\nHier werden alle Beobachtungen mit mehr als 5 Knollen selektiert.\n\npot.T5 &lt;-pot.sub %&gt;% filter(tubers&gt;5)\npot.T5\n\n# A tibble: 6 x 7\n# Groups:   variety, method [6]\n  variety   method     plant tubers weight infection humidity\n  &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 Costanera aeroponic      5      7   42           0     26.0\n2 Costanera bed            4      7  137.          1     41.6\n3 Costanera hydroponic     8      6   31.8         1     57.2\n4 Costanera pot            6      7  139.          0     41.6\n5 Mariva    aeroponic      7      6   99.2         0     31.8\n6 Mariva    pot            5      7  104.          0     41.4\n\npot.T5$tubers\n\n[1] 7 7 6 7 6 7\n\n\nzwei Bedingungen (Anzahl Knollen und Gewicht)\n\npot.sub %&gt;% filter(tubers&gt;=5, weight &gt; 80)\n\n# A tibble: 5 x 7\n# Groups:   variety, method [5]\n  variety   method    plant tubers weight infection humidity\n  &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 Costanera bed           4      7  137.          1     41.6\n2 Costanera pot           6      7  139.          0     41.6\n3 Mariva    aeroponic     7      6   99.2         0     31.8\n4 Mariva    pot           5      7  104.          0     41.4\n5 Unica     pot           9      5   97.7         1     58.7\n\n\n\n\narrange\nMit der Funktion arrange sortieren wir die Daten. Hier nach Anzahl tubers in aufsteigender Reihenfolge.\n\npot.sub %&gt;% arrange(tubers)\n\n# A tibble: 24 x 7\n# Groups:   variety, method [12]\n   variety   method     plant tubers weight infection humidity\n   &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1 Mariva    hydroponic     9      1   7.85         0     48.5\n 2 Mariva    hydroponic     9      2  10.8          0     44.6\n 3 Unica     aeroponic      6      2 112.           0     27.5\n 4 Unica     hydroponic     6      2  17.1          0     50.2\n 5 Unica     hydroponic     4      2  21.8          0     14.3\n 6 Costanera pot            5      3 110.           0     26.6\n 7 Unica     bed            9      3  38            0     56.8\n 8 Unica     aeroponic      7      4  50.1          0     40.0\n 9 Unica     bed            9      4 124.           0     41.8\n10 Unica     pot            7      4  50.4          0     36.0\n# i 14 more rows\n\n\nund hier in absteigender Reihenfolge durch Funktion desc():\n\npot.sub %&gt;% arrange(desc(tubers))\n\n# A tibble: 24 x 7\n# Groups:   variety, method [12]\n   variety   method     plant tubers weight infection humidity\n   &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1 Costanera aeroponic      5      7   42           0     26.0\n 2 Costanera bed            4      7  137.          1     41.6\n 3 Costanera pot            6      7  139.          0     41.6\n 4 Mariva    pot            5      7  104.          0     41.4\n 5 Costanera hydroponic     8      6   31.8         1     57.2\n 6 Mariva    aeroponic      7      6   99.2         0     31.8\n 7 Costanera aeroponic      1      5   24.1         0     33.9\n 8 Costanera bed            3      5   78           1     51.0\n 9 Costanera hydroponic     4      5   42           1     56.8\n10 Mariva    aeroponic      5      5   72.6         0     24.5\n# i 14 more rows\n\n\nund hier für zwei Kriterien (wobei letzteres Kriterium nur bei gleichen Werten in erstem Kriterium sortiert wird)\n\npot.sub %&gt;% arrange(desc(tubers),desc(weight))\n\n# A tibble: 24 x 7\n# Groups:   variety, method [12]\n   variety   method     plant tubers weight infection humidity\n   &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1 Costanera pot            6      7  139.          0     41.6\n 2 Costanera bed            4      7  137.          1     41.6\n 3 Mariva    pot            5      7  104.          0     41.4\n 4 Costanera aeroponic      5      7   42           0     26.0\n 5 Mariva    aeroponic      7      6   99.2         0     31.8\n 6 Costanera hydroponic     8      6   31.8         1     57.2\n 7 Unica     pot            9      5   97.7         1     58.7\n 8 Costanera bed            3      5   78           1     51.0\n 9 Mariva    bed            8      5   77.3         0     16.3\n10 Mariva    aeroponic      5      5   72.6         0     24.5\n# i 14 more rows\n\n\n\n\nslice\nMit der Funktion slice selektieren wir die Zeilen. Hier Zeile 5 bis 10 im Datensatz pot.\n\npot %&gt;% slice(5:10)\n\n  variety method plant tubers weight infection humidity\n1   Unica    pot     5      2   11.3         1 49.62655\n2   Unica    pot     6      2   17.8         0 54.42449\n3   Unica    pot     7      3   28.1         0 38.82654\n4   Unica    pot     8      6   33.0         0 17.36043\n5   Unica    pot     9      9   81.5         0 24.55165\n6   Unica    pot    10      6   71.1         0 27.55136\n\n\nDie Funktion slice_head(n=3) zeigt die ersten drei Zeilen des Datensatzes an.\n\npot %&gt;% slice_head(n=3)\n\n  variety method plant tubers weight infection humidity\n1   Unica    pot     1      9  209.9         0 26.12342\n2   Unica    pot     2      3  248.4         0 30.23136\n3   Unica    pot     3      4   53.6         0 52.47987\n\n\nDie Funktion slice_tail(n=3) zeigt die letzten drei Zeilen des Datensatzes an.\n\npot %&gt;% slice_tail(n=3)\n\n    variety    method plant tubers weight infection humidity\n1 Costanera aeroponic     8      6   29.1         1 49.90505\n2 Costanera aeroponic     9      4   17.6         0 54.39016\n3 Costanera aeroponic    10      7   36.9         0 29.03782\n\n\nAlternativ könnte man auch die Funtionen head(pot) und tail(pot) nutzen.\nDie Funktion slice_sample(n=3) wählt zufällig drei Beobachtungen aus.\n\npot %&gt;% slice_sample(n=3)\n\n    variety     method plant tubers weight infection humidity\n1     Unica        bed     3      2   18.2         1 42.24794\n2 Costanera        bed     2      4  118.5         1 33.23794\n3     Unica hydroponic     3      2   58.7         0 13.54122\n\n\nWenn man immer das gleiche Set an Proben zufällig auswählen möchte, d.h. ein reproduzierbares Ergebnis erzielen möchte, dann setzt man vorher den seed. Die Zahl (hier 123) kann beliebig gewählt werden.\n\nset.seed(123)\npot %&gt;% slice_sample(n=3)\n\n    variety     method plant tubers weight infection humidity\n1    Mariva        bed     5      3   37.8         1 42.87366\n2 Costanera hydroponic     3      7   18.6         1 54.46725\n3    Mariva        bed     9      6   99.4         0 38.52317\n\n\nDie Funktion slice_max(n=3) wählt die drei Beobachtungen mit dem höchsten Gewicht aus.\n\npot %&gt;% slice_max(weight, n=3)\n\n  variety    method plant tubers weight infection humidity\n1  Mariva aeroponic     6     13  323.3         0 45.84920\n2   Unica aeroponic     9      5  265.4         0 17.41489\n3   Unica       pot     2      3  248.4         0 30.23136"
  },
  {
    "objectID": "Themen/02/02_DeskriptiveStats.html#spalten",
    "href": "Themen/02/02_DeskriptiveStats.html#spalten",
    "title": "Datenmanagement und deskriptive Statistik",
    "section": "Spalten",
    "text": "Spalten\nHäufig arbeitet man mit großen Datensätzen und vielen Variablen.\n\nselect\nMit der Funktion select kann man Variablen auswählen, indem ich sie durch Komme getrennt aufliste:\n\npot.sub %&gt;% select(variety, method, tubers, weight)\n\n# A tibble: 24 x 4\n# Groups:   variety, method [12]\n   variety   method     tubers weight\n   &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;\n 1 Costanera aeroponic       5   24.1\n 2 Costanera aeroponic       7   42  \n 3 Costanera bed             7  137. \n 4 Costanera bed             5   78  \n 5 Costanera hydroponic      6   31.8\n 6 Costanera hydroponic      5   42  \n 7 Costanera pot             3  110. \n 8 Costanera pot             7  139. \n 9 Mariva    aeroponic       6   99.2\n10 Mariva    aeroponic       5   72.6\n# i 14 more rows\n\n\noder von variety bis weight\n\npot.sub %&gt;% select(variety:weight)\n\n# A tibble: 24 x 5\n# Groups:   variety, method [12]\n   variety   method     plant tubers weight\n   &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 Costanera aeroponic      1      5   24.1\n 2 Costanera aeroponic      5      7   42  \n 3 Costanera bed            4      7  137. \n 4 Costanera bed            3      5   78  \n 5 Costanera hydroponic     8      6   31.8\n 6 Costanera hydroponic     4      5   42  \n 7 Costanera pot            5      3  110. \n 8 Costanera pot            6      7  139. \n 9 Mariva    aeroponic      7      6   99.2\n10 Mariva    aeroponic      5      5   72.6\n# i 14 more rows\n\n\nwie oben nur ohne plant\n\npot.sub %&gt;% \n  select(variety:weight)%&gt;% \n  select(-plant)\n\n# A tibble: 24 x 4\n# Groups:   variety, method [12]\n   variety   method     tubers weight\n   &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;\n 1 Costanera aeroponic       5   24.1\n 2 Costanera aeroponic       7   42  \n 3 Costanera bed             7  137. \n 4 Costanera bed             5   78  \n 5 Costanera hydroponic      6   31.8\n 6 Costanera hydroponic      5   42  \n 7 Costanera pot             3  110. \n 8 Costanera pot             7  139. \n 9 Mariva    aeroponic       6   99.2\n10 Mariva    aeroponic       5   72.6\n# i 14 more rows\n\n# oder so\npot.sub %&gt;% \n  select(c(variety:weight,-plant))\n\n# A tibble: 24 x 4\n# Groups:   variety, method [12]\n   variety   method     tubers weight\n   &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;\n 1 Costanera aeroponic       5   24.1\n 2 Costanera aeroponic       7   42  \n 3 Costanera bed             7  137. \n 4 Costanera bed             5   78  \n 5 Costanera hydroponic      6   31.8\n 6 Costanera hydroponic      5   42  \n 7 Costanera pot             3  110. \n 8 Costanera pot             7  139. \n 9 Mariva    aeroponic       6   99.2\n10 Mariva    aeroponic       5   72.6\n# i 14 more rows\n\n# aber nicht so\npot.sub %&gt;% \n  select(c(-plant, variety:weight))\n\n# A tibble: 24 x 7\n# Groups:   variety, method [12]\n   variety   method     tubers weight infection humidity plant\n   &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 Costanera aeroponic       5   24.1         0     33.9     1\n 2 Costanera aeroponic       7   42           0     26.0     5\n 3 Costanera bed             7  137.          1     41.6     4\n 4 Costanera bed             5   78           1     51.0     3\n 5 Costanera hydroponic      6   31.8         1     57.2     8\n 6 Costanera hydroponic      5   42           1     56.8     4\n 7 Costanera pot             3  110.          0     26.6     5\n 8 Costanera pot             7  139.          0     41.6     6\n 9 Mariva    aeroponic       6   99.2         0     31.8     7\n10 Mariva    aeroponic       5   72.6         0     24.5     5\n# i 14 more rows\n\n\n\npot.sub %&gt;% \n  select(ends_with(\"t\")) \n\nAdding missing grouping variables: `variety`, `method`\n\n\n# A tibble: 24 x 4\n# Groups:   variety, method [12]\n   variety   method     plant weight\n   &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n 1 Costanera aeroponic      1   24.1\n 2 Costanera aeroponic      5   42  \n 3 Costanera bed            4  137. \n 4 Costanera bed            3   78  \n 5 Costanera hydroponic     8   31.8\n 6 Costanera hydroponic     4   42  \n 7 Costanera pot            5  110. \n 8 Costanera pot            6  139. \n 9 Mariva    aeroponic      7   99.2\n10 Mariva    aeroponic      5   72.6\n# i 14 more rows\n\n\n\npot %&gt;% \n  select(ends_with(\"t\")) %&gt;% \n  slice_sample(n=8)\n\n  plant weight\n1     4  65.60\n2     5  78.30\n3     6  10.35\n4     6  14.15\n5     8  43.30\n6     9  34.10\n7     9  16.70\n8     4 142.80\n\n\n\n\nrename\nVariablen können umbenannt werden durch die Funktion rename().\n\npot.sub %&gt;% rename(plant_ID=plant)\n\n# A tibble: 24 x 7\n# Groups:   variety, method [12]\n   variety   method     plant_ID tubers weight infection humidity\n   &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1 Costanera aeroponic         1      5   24.1         0     33.9\n 2 Costanera aeroponic         5      7   42           0     26.0\n 3 Costanera bed               4      7  137.          1     41.6\n 4 Costanera bed               3      5   78           1     51.0\n 5 Costanera hydroponic        8      6   31.8         1     57.2\n 6 Costanera hydroponic        4      5   42           1     56.8\n 7 Costanera pot               5      3  110.          0     26.6\n 8 Costanera pot               6      7  139.          0     41.6\n 9 Mariva    aeroponic         7      6   99.2         0     31.8\n10 Mariva    aeroponic         5      5   72.6         0     24.5\n# i 14 more rows\n\n\n\npot.sub\n\n# A tibble: 24 x 7\n# Groups:   variety, method [12]\n   variety   method     plant tubers weight infection humidity\n   &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1 Costanera aeroponic      1      5   24.1         0     33.9\n 2 Costanera aeroponic      5      7   42           0     26.0\n 3 Costanera bed            4      7  137.          1     41.6\n 4 Costanera bed            3      5   78           1     51.0\n 5 Costanera hydroponic     8      6   31.8         1     57.2\n 6 Costanera hydroponic     4      5   42           1     56.8\n 7 Costanera pot            5      3  110.          0     26.6\n 8 Costanera pot            6      7  139.          0     41.6\n 9 Mariva    aeroponic      7      6   99.2         0     31.8\n10 Mariva    aeroponic      5      5   72.6         0     24.5\n# i 14 more rows\n\n\nAuch hier müssen wir die Daten in einem neuen data.frame pot.sub1 speichern oder überschreiben (pot.sub=pot.sub %&gt;% rename(plant_ID=plant)), um auf die neue Variable zugreifen zu können.\n\npot.sub1=pot.sub %&gt;% rename(plant_ID=plant)\npot.sub1\n\n# A tibble: 24 x 7\n# Groups:   variety, method [12]\n   variety   method     plant_ID tubers weight infection humidity\n   &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1 Costanera aeroponic         1      5   24.1         0     33.9\n 2 Costanera aeroponic         5      7   42           0     26.0\n 3 Costanera bed               4      7  137.          1     41.6\n 4 Costanera bed               3      5   78           1     51.0\n 5 Costanera hydroponic        8      6   31.8         1     57.2\n 6 Costanera hydroponic        4      5   42           1     56.8\n 7 Costanera pot               5      3  110.          0     26.6\n 8 Costanera pot               6      7  139.          0     41.6\n 9 Mariva    aeroponic         7      6   99.2         0     31.8\n10 Mariva    aeroponic         5      5   72.6         0     24.5\n# i 14 more rows\n\n\n\n\nmutate\nEine neue Variable kann durch die Funktion mutate berechnet und eingefügt werden.\nBeispielsweise könnten wir das Gewicht in kg statt g angeben. Es wird eine neue Variable erzeugt weight_kg indem weight durch 1000 geteilt wird.\n\npot.sub %&gt;% \n  mutate(weight_kg=weight/1000)\n\n# A tibble: 24 x 8\n# Groups:   variety, method [12]\n   variety   method     plant tubers weight infection humidity weight_kg\n   &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n 1 Costanera aeroponic      1      5   24.1         0     33.9    0.0241\n 2 Costanera aeroponic      5      7   42           0     26.0    0.042 \n 3 Costanera bed            4      7  137.          1     41.6    0.137 \n 4 Costanera bed            3      5   78           1     51.0    0.078 \n 5 Costanera hydroponic     8      6   31.8         1     57.2    0.0318\n 6 Costanera hydroponic     4      5   42           1     56.8    0.042 \n 7 Costanera pot            5      3  110.          0     26.6    0.110 \n 8 Costanera pot            6      7  139.          0     41.6    0.139 \n 9 Mariva    aeroponic      7      6   99.2         0     31.8    0.0992\n10 Mariva    aeroponic      5      5   72.6         0     24.5    0.0726\n# i 14 more rows\n\n\nDamit diese neue Variable im Datensatz nicht nur erscheint, sondern auch zugreifbar ist, speichere ich den Datensatz unter einem neuen Namen ab. Man könnte ihn auch überschreiben. Ausserdem noch zwei Beispiele für eine log- und Wurzel-Transformation.\n\npot.sub1=pot.sub %&gt;% \n  mutate(weight_kg=weight/1000,\n         weight.sqrt=sqrt(weight),\n         weight.l=log(weight),\n         tubers.l=log(tubers))\npot.sub1\n\n# A tibble: 24 x 11\n# Groups:   variety, method [12]\n   variety   method plant tubers weight infection humidity weight_kg weight.sqrt\n   &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 Costanera aerop~     1      5   24.1         0     33.9    0.0241        4.91\n 2 Costanera aerop~     5      7   42           0     26.0    0.042         6.48\n 3 Costanera bed        4      7  137.          1     41.6    0.137        11.7 \n 4 Costanera bed        3      5   78           1     51.0    0.078         8.83\n 5 Costanera hydro~     8      6   31.8         1     57.2    0.0318        5.64\n 6 Costanera hydro~     4      5   42           1     56.8    0.042         6.48\n 7 Costanera pot        5      3  110.          0     26.6    0.110        10.5 \n 8 Costanera pot        6      7  139.          0     41.6    0.139        11.8 \n 9 Mariva    aerop~     7      6   99.2         0     31.8    0.0992        9.96\n10 Mariva    aerop~     5      5   72.6         0     24.5    0.0726        8.52\n# i 14 more rows\n# i 2 more variables: weight.l &lt;dbl&gt;, tubers.l &lt;dbl&gt;\n\n\n\nVariable in Faktor umwandeln\nBeim Importieren von Daten werden Variablen häufig als character eingelesen (oder als numeric), die für die spätere Analyse aber als Faktor benötigt werden. Wir können diese Variablen in Faktoren umwandeln, können diese überschreiben oder (wie unten gezeigt) geben ihnen einen neuen Namen mit dem Appendix “.f”.\n\npot=pot %&gt;% \n    mutate(variety.f=as.factor(variety),\n           method.f=as.factor(method),\n           infection.f=as.factor(infection))\n\nalternativer Code zu oben:\n\npot$variety.f=as.factor(pot$variety)\npot$method.f=as.factor(pot$method)\npot$infection.f=as.factor(pot$infection)\nstr(pot)\n\nMit across(where(is.character),as.factor) werden alle Variablen, die als Charakter eingelesen sind, in einen Faktor umgewandelt.\n\npot2&lt;-read.xlsx(\"potato.xlsx\", sheet=1)\nstr(pot2)\n\n'data.frame':   478 obs. of  7 variables:\n $ variety  : chr  \"Unica\" \"Unica\" \"Unica\" \"Unica\" ...\n $ method   : chr  \"pot\" \"pot\" \"pot\" \"pot\" ...\n $ plant    : num  1 2 3 4 5 6 7 8 9 10 ...\n $ tubers   : num  9 3 4 4 2 2 3 6 9 6 ...\n $ weight   : num  209.9 248.4 53.6 77.2 11.3 ...\n $ infection: num  0 0 0 0 1 0 0 0 0 0 ...\n $ humidity : num  26.1 30.2 52.5 34 49.6 ...\n\npot3&lt;- pot2 %&gt;% mutate(across(where(is.character),as.factor))\nstr(pot3)\n\n'data.frame':   478 obs. of  7 variables:\n $ variety  : Factor w/ 3 levels \"Costanera\",\"Mariva\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ method   : Factor w/ 4 levels \"aeroponic\",\"bed\",..: 4 4 4 4 4 4 4 4 4 4 ...\n $ plant    : num  1 2 3 4 5 6 7 8 9 10 ...\n $ tubers   : num  9 3 4 4 2 2 3 6 9 6 ...\n $ weight   : num  209.9 248.4 53.6 77.2 11.3 ...\n $ infection: num  0 0 0 0 1 0 0 0 0 0 ...\n $ humidity : num  26.1 30.2 52.5 34 49.6 ...\n\n\nBitte beachten, dass infection damit nicht als Faktor umgewandelt wird, da es als numerische Variable eingelesen wurde. Wir müssen also immer nochmal die Struktur überprüfen und ggfls. nachjustieren.\n\npot4&lt;- pot2 %&gt;% mutate(across(where(is.character),as.factor),\n                       infection=as.factor(infection))\nstr(pot4)\n\n'data.frame':   478 obs. of  7 variables:\n $ variety  : Factor w/ 3 levels \"Costanera\",\"Mariva\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ method   : Factor w/ 4 levels \"aeroponic\",\"bed\",..: 4 4 4 4 4 4 4 4 4 4 ...\n $ plant    : num  1 2 3 4 5 6 7 8 9 10 ...\n $ tubers   : num  9 3 4 4 2 2 3 6 9 6 ...\n $ weight   : num  209.9 248.4 53.6 77.2 11.3 ...\n $ infection: Factor w/ 2 levels \"0\",\"1\": 1 1 1 1 2 1 1 1 1 1 ...\n $ humidity : num  26.1 30.2 52.5 34 49.6 ...\n\n\nDer große Vorteil von dplyr ist, dass ihr alle Schritte in einen Code schreiben und ihn damit gut nachvollziehen könnt.\n\npot1=pot%&gt;% \n  filter(variety==c(\"Mariva\", \"Costanera\"), tubers&gt;7) %&gt;% \n  mutate(weight_kg=weight/1000, \n         variety.f=as.factor(variety),\n         method.f=as.factor(method),\n         infection.f=as.factor(infection)) %&gt;% \n  select(!c(plant,infection, weight))\npot1\n\n     variety     method tubers humidity variety.f   method.f infection.f\n1     Mariva        bed      9 36.24464    Mariva        bed           0\n2     Mariva        bed     10 13.83214    Mariva        bed           0\n3     Mariva        bed      8 34.63448    Mariva        bed           0\n4  Costanera        pot      8 62.30639 Costanera        pot           1\n5  Costanera hydroponic      8 51.21347 Costanera hydroponic           1\n6  Costanera  aeroponic      9 40.65539 Costanera  aeroponic           0\n7     Mariva        pot     10 27.90961    Mariva        pot           0\n8     Mariva  aeroponic      8 55.48964    Mariva  aeroponic           1\n9  Costanera        pot      8 27.17098 Costanera        pot           0\n10 Costanera        pot      9 25.69880 Costanera        pot           0\n11    Mariva        bed     11 47.62537    Mariva        bed           0\n12    Mariva        bed      8 62.26231    Mariva        bed           1\n13    Mariva  aeroponic     10 28.71567    Mariva  aeroponic           0\n14    Mariva  aeroponic      8 54.04355    Mariva  aeroponic           0\n15    Mariva        pot     10 26.39289    Mariva        pot           0\n16    Mariva        bed     10 54.14047    Mariva        bed           1\n17    Mariva        bed      8 56.14320    Mariva        bed           1\n18    Mariva        bed     10 39.75289    Mariva        bed           0\n19    Mariva  aeroponic      9 30.72462    Mariva  aeroponic           0\n20    Mariva  aeroponic      8 36.82570    Mariva  aeroponic           0\n21 Costanera        pot      8 44.07980 Costanera        pot           0\n22 Costanera        bed      8 61.03558 Costanera        bed           1\n23 Costanera hydroponic      8 69.46336 Costanera hydroponic           1\n   weight_kg\n1     0.2274\n2     0.0338\n3     0.0948\n4     0.1624\n5     0.0486\n6     0.0781\n7     0.0773\n8     0.1205\n9     0.1449\n10    0.1391\n11    0.1182\n12    0.1250\n13    0.1883\n14    0.1656\n15    0.0644\n16    0.1069\n17    0.1332\n18    0.1183\n19    0.0759\n20    0.1684\n21    0.1531\n22    0.0494\n23    0.0253"
  },
  {
    "objectID": "Themen/02/02_DeskriptiveStats.html#übung-2.1.",
    "href": "Themen/02/02_DeskriptiveStats.html#übung-2.1.",
    "title": "Datenmanagement und deskriptive Statistik",
    "section": "Übung 2.1.",
    "text": "Übung 2.1.\nDie Körpergröße, Schuhgröße, Geschlecht und Augenfarbe von Kursteilnehmer wurde ermittelt. Importiere bitte die Daten Kursteilnehmer.xlsx in R und benenne den data.frame mit md.\nErstelle einen neuen Datensatz mit Beobachtungen von Kursteilnehmern mit jeweils:\n\nblauen Augen (md1)\nKörpergröße größer 1,70 m (md2)\nblauen und grünen Augen (md3)\nohne Schuhgröße (md4)\n\nEnde Übung 2.1."
  },
  {
    "objectID": "Themen/02/02_DeskriptiveStats.html#qualitative-daten",
    "href": "Themen/02/02_DeskriptiveStats.html#qualitative-daten",
    "title": "Datenmanagement und deskriptive Statistik",
    "section": "Qualitative Daten",
    "text": "Qualitative Daten\nQualitative Variablen sind in unserem Beispiel die Sorte, der Krankheitsbefall und die Methode. Diese Daten beschreiben wir durch Häufigkeitstabellen (Kontingenztabellen), die angeben, wie häufig eine Merkmalsausprägung bzw. -kombination in unserem Datensatz vorkommt. Wir nutzen die Funktion count()aus dem Package dplyr\n\npot %&gt;% count(variety)\n\n    variety   n\n1 Costanera 158\n2    Mariva 160\n3     Unica 160\n\n\noder die Funktion table().\n\ntable(pot$variety) \n\n\nCostanera    Mariva     Unica \n      158       160       160 \n\n\nDie Funktion prop.table() berechnet uns die relativen Anteile jeder Merkmalsausprägung bzw. -kombination.\n\npot %&gt;% count(variety) %&gt;% \n  mutate(prop = prop.table(n))\n\n    variety   n      prop\n1 Costanera 158 0.3305439\n2    Mariva 160 0.3347280\n3     Unica 160 0.3347280\n\n\n\nprop.table(table(pot$variety)) # relativ, i.e. Anteil der Beobachtungen an der Gesamtzahl der Beobachtungen \n\n\nCostanera    Mariva     Unica \n0.3305439 0.3347280 0.3347280 \n\n\nHäufigkeitstabellen können für 2 Kombinationen (Merkmale) erstellt werden, indem man beide Variablen in der Funktion count() oder table() angibt.\n\npot %&gt;% count(variety, infection) %&gt;% \n  mutate(prop = prop.table(n))\n\n    variety infection   n       prop\n1 Costanera         0  77 0.16108787\n2 Costanera         1  81 0.16945607\n3    Mariva         0 119 0.24895397\n4    Mariva         1  41 0.08577406\n5     Unica         0 122 0.25523013\n6     Unica         1  38 0.07949791\n\n\n\ntable(pot$variety, pot$infection)\n\n           \n              0   1\n  Costanera  77  81\n  Mariva    119  41\n  Unica     122  38\n\nprop.table(table(pot$variety, pot$infection)) # relative Häufigkeit\n\n           \n                     0          1\n  Costanera 0.16108787 0.16945607\n  Mariva    0.24895397 0.08577406\n  Unica     0.25523013 0.07949791\n\n\nHäufigkeitstabelle für 3 Kombinationen\n\npot %&gt;% count(variety, method, infection) %&gt;% \n  mutate(prop = prop.table(n))\n\n     variety     method infection  n       prop\n1  Costanera  aeroponic         0 28 0.05857741\n2  Costanera  aeroponic         1 12 0.02510460\n3  Costanera        bed         0  9 0.01882845\n4  Costanera        bed         1 31 0.06485356\n5  Costanera hydroponic         0 11 0.02301255\n6  Costanera hydroponic         1 27 0.05648536\n7  Costanera        pot         0 29 0.06066946\n8  Costanera        pot         1 11 0.02301255\n9     Mariva  aeroponic         0 27 0.05648536\n10    Mariva  aeroponic         1 13 0.02719665\n11    Mariva        bed         0 29 0.06066946\n12    Mariva        bed         1 11 0.02301255\n13    Mariva hydroponic         0 31 0.06485356\n14    Mariva hydroponic         1  9 0.01882845\n15    Mariva        pot         0 32 0.06694561\n16    Mariva        pot         1  8 0.01673640\n17     Unica  aeroponic         0 30 0.06276151\n18     Unica  aeroponic         1 10 0.02092050\n19     Unica        bed         0 31 0.06485356\n20     Unica        bed         1  9 0.01882845\n21     Unica hydroponic         0 32 0.06694561\n22     Unica hydroponic         1  8 0.01673640\n23     Unica        pot         0 29 0.06066946\n24     Unica        pot         1 11 0.02301255\n\n\n\ntable(pot$variety, pot$method, pot$infection)\n\n, ,  = 0\n\n           \n            aeroponic bed hydroponic pot\n  Costanera        28   9         11  29\n  Mariva           27  29         31  32\n  Unica            30  31         32  29\n\n, ,  = 1\n\n           \n            aeroponic bed hydroponic pot\n  Costanera        12  31         27  11\n  Mariva           13  11          9   8\n  Unica            10   9          8  11\n\nftable(pot$variety, pot$method, pot$infection)\n\n                       0  1\n                           \nCostanera aeroponic   28 12\n          bed          9 31\n          hydroponic  11 27\n          pot         29 11\nMariva    aeroponic   27 13\n          bed         29 11\n          hydroponic  31  9\n          pot         32  8\nUnica     aeroponic   30 10\n          bed         31  9\n          hydroponic  32  8\n          pot         29 11"
  },
  {
    "objectID": "Themen/02/02_DeskriptiveStats.html#quantitative-daten",
    "href": "Themen/02/02_DeskriptiveStats.html#quantitative-daten",
    "title": "Datenmanagement und deskriptive Statistik",
    "section": "Quantitative Daten",
    "text": "Quantitative Daten\n\nMittelwert und Median\n\nArithmetischer Mittelwert mean()\nMedian median(): Wert, der an der mittleren (zentralen) Stelle steht, wenn man die Werte der Größe nach sortiert\nMedian besser als arithmetischer Mittelwert bei:\n\nordinalskalierten Beobachtungen\ngeringem Stichprobenumfang\nasymmetrischen Verteilungen\nVerdacht auf Ausreißer\n\n\n\npot %&gt;% \n  summarise(tubers_avg=mean(tubers))\n\n  tubers_avg\n1   4.721757\n\n\n\npot %&gt;% \n  summarise(tubers_avg=mean(tubers),\n            tubers_med=median(tubers))\n\n  tubers_avg tubers_med\n1   4.721757          4\n\n\n\nmean(pot$tubers)\n\n[1] 4.721757\n\nmedian(pot$tubers)\n\n[1] 4\n\n\n\n\nVarianz und Standardabweichung\nsind Maße, die die Streuung der Daten beschreiben.\n\nVarianz var()\nStandardabweichung sd()\nStandardabweichung in gleicher Einheit wie Mittelwert\nWenn Mittelwert und Standardabweichung einer normalverteilten Grundgesamtheit bekannt ist, kann die Wahrscheinlichkeit berechnet werden, mit der ein Wert auftritt.\n\n\npot %&gt;% \n  summarise(tubers_avg=mean(tubers),\n            tubers_med=median(tubers),\n            tubers_var=var(tubers),\n            tubers_sd=sd(tubers))\n\n  tubers_avg tubers_med tubers_var tubers_sd\n1   4.721757          4   5.190763  2.278324\n\n\n\nvar(pot$tubers)\n\n[1] 5.190763\n\nsd(pot$tubers)\n\n[1] 2.278324\n\n\n\n\nStandardfehler des Mittelwertes (sem)\nbeschreibt die Genauigkeit der Berechnung des Stichproben-Mittelwertes.\n\nsem = sd/sqrt(n)\nstd &lt;- function(x) {sd(x, na.rm=TRUE)/sqrt(length(na.omit(x)))}\nkein Streuungsmaß der Stichprobe\nje mehr Datenpunkte, desto genauer die Schätzung des Mittelwertes\nMittelwert ± 1 sem beschreibt den Wertebereich, in dem wir mit 68%iger Wahrscheinlichkeit den wahren Mittelwert erwarten\nMittelwert ± 1,96 sem 95% Wahrscheinlichkeit i.e. Konfidenzintervall\nMittelwert ± 2 sem 95,5%\nMittelwert ± 3 sem 99,7%\n\n\n# Funktion für den Standardfehler\nstd &lt;- function(x) {sd(x, na.rm=TRUE)/sqrt(length(na.omit(x)))} #muss nur einmal definiert werden\nstd(pot$tubers)\n\n[1] 0.1042081\n\n\n\n\nweitere Maße zur beschreibenden Statistik:\n\nMinimum min()\nMaximum max()\nWertebereich range()\nQuantile quantile()\nVarianzkoeffizient: CV = sd/mean\n\n\nmin(pot$tubers)\n\n[1] 0\n\nmax(pot$tubers)\n\n[1] 13\n\nrange(pot$tubers)\n\n[1]  0 13\n\nquantile(pot$tubers)\n\n  0%  25%  50%  75% 100% \n   0    3    4    6   13 \n\nquantile(pot$tubers, p=c(0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.90, 0.95, 0.99))\n\n 1%  5% 10% 25% 50% 75% 90% 95% 99% \n  0   2   2   3   4   6   8   9  11 \n\n#Funktion für Variationskoeffizienten\nCV &lt;- function(x) {sd(x, na.rm=TRUE)/mean(x, na.rm=TRUE)} \n\n\npot %&gt;% \n  summarise(tubers_avg=mean(tubers),\n            tubers_med=median(tubers),\n            tubers_var=var(tubers),\n            tubers_sd=sd(tubers),\n            tubers_std=std(tubers),\n            tubers_min=min(tubers),\n            tubers_max=max(tubers),\n            tubers_q25=quantile(tubers, 0.25),\n            tubers_q75=quantile(tubers, 0.75),\n            tubers_CV=CV(tubers))\n\n  tubers_avg tubers_med tubers_var tubers_sd tubers_std tubers_min tubers_max\n1   4.721757          4   5.190763  2.278324  0.1042081          0         13\n  tubers_q25 tubers_q75 tubers_CV\n1          3          6 0.4825162"
  },
  {
    "objectID": "Themen/02/02_DeskriptiveStats.html#anwendungsbeispiele",
    "href": "Themen/02/02_DeskriptiveStats.html#anwendungsbeispiele",
    "title": "Datenmanagement und deskriptive Statistik",
    "section": "Anwendungsbeispiele",
    "text": "Anwendungsbeispiele\nEine erste einfache Beschreibung der Daten kann mit der Funktion summary() erfolgen. Hier sieht man jetzt den Unterschied im Output zwischen variety (als character) und variety.f (als factor).\n\nsummary(pot)\n\n   variety             method              plant           tubers      \n Length:478         Length:478         Min.   : 1.00   Min.   : 0.000  \n Class :character   Class :character   1st Qu.: 3.00   1st Qu.: 3.000  \n Mode  :character   Mode  :character   Median : 5.00   Median : 4.000  \n                                       Mean   : 5.49   Mean   : 4.722  \n                                       3rd Qu.: 8.00   3rd Qu.: 6.000  \n                                       Max.   :10.00   Max.   :13.000  \n     weight         infection         humidity         variety.f  \n Min.   :  0.00   Min.   :0.0000   Min.   : 0.00   Costanera:158  \n 1st Qu.: 26.07   1st Qu.:0.0000   1st Qu.:28.53   Mariva   :160  \n Median : 61.00   Median :0.0000   Median :38.14   Unica    :160  \n Mean   : 72.77   Mean   :0.3347   Mean   :38.40                  \n 3rd Qu.:109.25   3rd Qu.:1.0000   3rd Qu.:48.47                  \n Max.   :323.30   Max.   :1.0000   Max.   :80.00                  \n       method.f   infection.f\n aeroponic :120   0:318      \n bed       :120   1:160      \n hydroponic:118              \n pot       :120              \n                             \n                             \n\n\nMöchte man eine beschreibende Statistik für jede numerische Variable berechnen, kann die Funktion summarise_if(is.numeric, mean, na.rm = TRUE) genutzt werden. Im Beispiel berechnen wir den Mittelwert für alle Variablen im data.frame pot.\n\npot %&gt;%\n  summarise_if(is.numeric, mean, na.rm = TRUE)\n\n    plant   tubers   weight infection humidity\n1 5.48954 4.721757 72.77259  0.334728 38.39556\n\n\nHäufig möchte man die beschreibende Statistik für ein oder mehrere Gruppierungslevel berechnen. Bspw. das mittleres Gewicht je Sorte. Wir nutzen hierfür die Funktion group_by():\n\npot %&gt;% group_by(variety) %&gt;% \n  summarise(weight_avg=mean(weight, na.rm = TRUE))\n\n# A tibble: 3 x 2\n  variety   weight_avg\n  &lt;chr&gt;          &lt;dbl&gt;\n1 Costanera       74.1\n2 Mariva          74.7\n3 Unica           69.6\n\n\nBsp.: mittleres Gewicht je Sorte und Methode\n\npot %&gt;% group_by(variety, method) %&gt;% \n  summarise(weight_avg=mean(weight, na.rm = TRUE))\n\n`summarise()` has grouped output by 'variety'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 12 x 3\n# Groups:   variety [3]\n   variety   method     weight_avg\n   &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;\n 1 Costanera aeroponic        40.2\n 2 Costanera bed              87.5\n 3 Costanera hydroponic       25.1\n 4 Costanera pot             141. \n 5 Mariva    aeroponic        95.4\n 6 Mariva    bed              96.8\n 7 Mariva    hydroponic       14.3\n 8 Mariva    pot              92.2\n 9 Unica     aeroponic        88.5\n10 Unica     bed              69.1\n11 Unica     hydroponic       26.3\n12 Unica     pot              94.6\n\n\nBsp.: Mittelwert und Standardabweichung von Gewicht je Sorte und Methode\n\npot %&gt;% group_by(variety, method) %&gt;% \n  summarise(weight_avg=mean(weight, na.rm = TRUE),\n            weight_sd=sd(weight, na.rm = TRUE))\n\n`summarise()` has grouped output by 'variety'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 12 x 4\n# Groups:   variety [3]\n   variety   method     weight_avg weight_sd\n   &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n 1 Costanera aeroponic        40.2     16.6 \n 2 Costanera bed              87.5     32.6 \n 3 Costanera hydroponic       25.1      8.17\n 4 Costanera pot             141.      22.2 \n 5 Mariva    aeroponic        95.4     54.8 \n 6 Mariva    bed              96.8     54.8 \n 7 Mariva    hydroponic       14.3      9.34\n 8 Mariva    pot              92.2     27.4 \n 9 Unica     aeroponic        88.5     70.8 \n10 Unica     bed              69.1     36.4 \n11 Unica     hydroponic       26.3     14.1 \n12 Unica     pot              94.6     60.3 \n\n\nHier ein Code für eine Übersichtstabelle zur Beschreibung der Daten:\n\nlibrary(tidyr)\npot %&gt;% summarise(across(where(is.numeric), .fns = \n                     list(min = min,\n                          median = median,\n                          mean = mean,\n                          stdev = sd,\n                          q25 = ~quantile(., 0.25),\n                          q75 = ~quantile(., 0.75),\n                          max = max, \n                          n=length))) %&gt;%\n  pivot_longer(everything(), names_sep='_', names_to=c('variable', '.value'))\n\n# A tibble: 5 x 9\n  variable    min median   mean  stdev   q25   q75   max     n\n  &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n1 plant         1    5    5.49   2.87    3     8     10    478\n2 tubers        0    4    4.72   2.28    3     6     13    478\n3 weight        0   61   72.8   53.6    26.1 109.   323.   478\n4 infection     0    0    0.335  0.472   0     1      1    478\n5 humidity      0   38.1 38.4   14.2    28.5  48.5   80    478\n\n\nund hier nur für tubers und weight:\n\npot %&gt;% summarise(across(c(\"tubers\", \"weight\"), .fns = \n                     list(min = min,\n                          median = median,\n                          mean = mean,\n                          stdev = sd,\n                          q25 = ~quantile(., 0.25),\n                          q75 = ~quantile(., 0.75),\n                          max = max, \n                          n=length))) %&gt;%\n  pivot_longer(everything(), names_sep='_', names_to=c('variable', '.value'))\n\n# A tibble: 2 x 9\n  variable   min median  mean stdev   q25   q75   max     n\n  &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n1 tubers       0      4  4.72  2.28   3      6    13    478\n2 weight       0     61 72.8  53.6   26.1  109.  323.   478\n\n\nbzw. ohne plant\n\npot %&gt;% \n  select(!plant)%&gt;% \n  summarise(across(where(is.numeric), .fns = \n                     list(min = min,\n                          median = median,\n                          mean = mean,\n                          stdev = sd,\n                          q25 = ~quantile(., 0.25),\n                          q75 = ~quantile(., 0.75),\n                          max = max, \n                          n=length))) %&gt;%\n  pivot_longer(everything(), names_sep='_', names_to=c('variable', '.value'))\n\n# A tibble: 4 x 9\n  variable    min median   mean  stdev   q25   q75   max     n\n  &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n1 tubers        0    4    4.72   2.28    3     6     13    478\n2 weight        0   61   72.8   53.6    26.1 109.   323.   478\n3 infection     0    0    0.335  0.472   0     1      1    478\n4 humidity      0   38.1 38.4   14.2    28.5  48.5   80    478\n\n\nfür unterschiedliche Methoden:\n\npot %&gt;%  group_by(method) %&gt;%\n  summarise(across(c(\"tubers\", \"weight\"), .fns = \n                     list(min = min,\n                          median = median,\n                          mean = mean,\n                          stdev = sd,\n                          q25 = ~quantile(., 0.25),\n                          q75 = ~quantile(., 0.75),\n                          max = max, \n                          n=length))) %&gt;%\n  pivot_longer(cols = -method,  names_sep='_', names_to=c('variable', '.value')) %&gt;% \n  arrange(variable)%&gt;% \n  relocate(variable)\n\n# A tibble: 8 x 10\n  variable method       min median   mean stdev   q25   q75   max     n\n  &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n1 tubers   aeroponic   0       5     4.76  2.29  3.75   6    13     120\n2 tubers   bed         1       5     5.55  2.37  4      7    13     120\n3 tubers   hydroponic  1       3     3.15  1.67  2      4     8     118\n4 tubers   pot         2       5     5.4   1.89  4      7    10     120\n5 weight   aeroponic   0      62.1  74.7  57.7  36.2   99.2 323.    120\n6 weight   bed        13.2    79.6  84.5  43.6  50.3  118.  227.    120\n7 weight   hydroponic  2.95   20.0  21.8  12.1  14.1   25.4  58.7   118\n8 weight   pot        11.3   111.  109.   45.9  72.7  143.  248.    120"
  },
  {
    "objectID": "Themen/02/02_DeskriptiveStats.html#übung-2.2.",
    "href": "Themen/02/02_DeskriptiveStats.html#übung-2.2.",
    "title": "Datenmanagement und deskriptive Statistik",
    "section": "Übung 2.2.",
    "text": "Übung 2.2.\nDie Körpergröße, Schuhgröße, Geschlecht und Augenfarbe von Kursteilnehmer wurde ermittelt. Importiere bitte die Daten Kursteilnehmer.xlsx in R und benenne den data.frame mit md.\n\nNutze die Funktion summary(md), um die Daten zu beschreiben.\nErmittele die Anzahl Frauen und Männer für jede Augenfarbe.\nBerechne die mittlere Körpergröße für Männer und Frauen.\nBerechne den Quotienten aus Körpergröße und Schuhgröße für jeden Teilnehmer und füge diesen in den data.frame ein.\nExportiere die Daten z.B. mit write.xlsx().\n\nZusatzaufgabe\n\nExportiere sowohl die Daten als auch eine Summary Statistics der Daten in einen xlsx-file mit zwei Tabellenblätter."
  },
  {
    "objectID": "Themen/03/03_Graph.html#jittered-boxplot-für-weight-method-und-variety",
    "href": "Themen/03/03_Graph.html#jittered-boxplot-für-weight-method-und-variety",
    "title": "Grafische Darstellungen",
    "section": "jittered boxplot für weight ~ method und variety",
    "text": "jittered boxplot für weight ~ method und variety\n\nggplot(data=pot, aes(x=method, y=weight, colour=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(shape=1, size=1)\n\n\n\n\nNoch nicht ganz richtig. Die Punkte haben zwar unterschiedliche Farben, sind aber nicht den Boxen der Sorten zugeordnet.\nMit dem Argument position=position_jitterdodge() können wir das ändern:\n\nggplot(data=pot, aes(x=method, y=weight, colour=variety)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5, position = position_dodge(width=0.75))+\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(position=position_jitterdodge(jitter.width = 0.1, jitter.height = 0, \n                                            dodge.width=0.75), \n              shape=1, size=1)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#dotplot",
    "href": "Themen/03/03_Graph.html#dotplot",
    "title": "Grafische Darstellungen",
    "section": "Dotplot",
    "text": "Dotplot\n\nggplot(data=pot, aes(x=method, y=weight, fill=variety)) +\n  geom_dotplot(binaxis=\"y\", stackdir=\"center\", binwidth = 5)+\n  facet_grid(~variety)+\n  theme(legend.position=\"none\", \n        axis.text.x=element_text(angle = 45, hjust = 1))"
  },
  {
    "objectID": "Themen/03/03_Graph.html#violinplot",
    "href": "Themen/03/03_Graph.html#violinplot",
    "title": "Grafische Darstellungen",
    "section": "Violinplot",
    "text": "Violinplot\nhttp://www.sthda.com/english/wiki/ggplot2-violin-plot-quick-start-guide-r-software-and-data-visualization\n\nggplot(data=pot, aes(x=method, y=weight))+ \n  geom_violin()\n\n\n\nggplot(data=pot, aes(x=method, y=weight))+ \n  geom_violin(trim=F)"
  },
  {
    "objectID": "Themen/03/03_Graph.html#facet_grid-und-facet_wrap",
    "href": "Themen/03/03_Graph.html#facet_grid-und-facet_wrap",
    "title": "Grafische Darstellungen",
    "section": "facet_grid() und facet_wrap()",
    "text": "facet_grid() und facet_wrap()\n\nReihenfolge ändern\nDie Reihenfolge der facets (oder auch der Levels im Boxplot) könnt ihr am einfachsten ändern, indem ihr die Reihenfolge der Faktorlevels definiert. Diese werden per default alphanumerisch sortiert. Ich habe nun nach dem Einlesen der Daten den Faktor variety.f2 mit dem Code variety.f2=factor(variety, levels=c(\"Unica\" , \"Costanera\", \"Mariva\")) in der Funktion mutate() eingepflegt und die Levelreihenfolge geändert. Alternativer Code ohne mutate() pot$variety.f2=factor(pot$variety, levels=c(\"Unica\" , \"Costanera\", \"Mariva\")) Weitere tolle Möglichkeiten, um Fakoren zu manuipulieren, bietet die library(forcats) https://forcats.tidyverse.org/.\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  facet_grid(~variety.f2)+\n  theme(legend.position=\"bottom\")\n\n\n\n\nalternativer Code mit der library(forcats) und der Funktion fct_relevel().\n\nlibrary(forcats)\npot %&gt;% \n  ggplot(aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  facet_grid(~fct_relevel(variety, \"Unica\", \"Mariva\"))+# hier neue Reihenfolge eingeben\n  theme(legend.position=\"bottom\")\n\n\n\n\n\n\nlabeller = label_both\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  facet_grid(~variety, labeller = label_both)+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\n\nlabeller = labeller(variety = Sorten.labs)\n\nSorten.labs &lt;- c(\"a) Costanera\", \"b) Mariva\", \"c) Unica\")\nnames(Sorten.labs) &lt;- c(\"Costanera\", \"Mariva\" ,   \"Unica\" )\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  facet_grid(~variety, labeller = labeller(variety = Sorten.labs))+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\n\nBeschriftung im Plot\ndabei bilden x und y die Koordinaten im Plot\n\nabc=data.frame(label=c(\"a)\", \"b)\", \"c)\"), \n               x=c(20,20,20), y=c(13,13, 13),\n               variety=c(levels(pot$variety.f)))\nabc\n\n  label  x  y   variety\n1    a) 20 13 Costanera\n2    b) 20 13    Mariva\n3    c) 20 13     Unica\n\n\ndie Beschrifftung erfolgt dann über die Funktion geom_text()\n\nggplot(data=pot, aes(x=weight, y=tubers, color=variety)) +\n  geom_point()+\n  facet_grid(~variety)+\n  geom_text(data  = abc,\n            aes(x = x, y = y, label = label), col=1)+\n  theme(legend.position=\"bottom\")"
  },
  {
    "objectID": "Themen/04/04_Anova.html",
    "href": "Themen/04/04_Anova.html",
    "title": "ANOVA",
    "section": "",
    "text": "library(dplyr)\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(ggpubr)\nlibrary(ggfortify)"
  },
  {
    "objectID": "Themen/04/04_Anova.html#beispiel-anova-proteingehalt",
    "href": "Themen/04/04_Anova.html#beispiel-anova-proteingehalt",
    "title": "ANOVA",
    "section": "Beispiel ANOVA Proteingehalt",
    "text": "Beispiel ANOVA Proteingehalt\nDie Proteingehalte von jeweils 8 zufällig ausgewählten Weizenproben der 4 Qualitätsklassen E, A, B und C wurden ermittelt. Unterscheiden sich die Qualitätsklassen im Proteingehalt?"
  },
  {
    "objectID": "Themen/04/04_Anova.html#daten-einlesen-kennenlernen-und-plotten",
    "href": "Themen/04/04_Anova.html#daten-einlesen-kennenlernen-und-plotten",
    "title": "ANOVA",
    "section": "Daten einlesen, kennenlernen und plotten",
    "text": "Daten einlesen, kennenlernen und plotten\nProtein.xlsx\n\nmd&lt;-read.xlsx(\"Protein.xlsx\")\n\n\nStruktur der eingelesenen Daten überprüfen\n\nstr(md)\n\n'data.frame':   32 obs. of  3 variables:\n $ ID   : num  1 2 3 4 5 6 7 8 9 10 ...\n $ Quali: chr  \"E\" \"E\" \"E\" \"E\" ...\n $ Prot : num  15.4 15.6 14.3 13.8 15.4 ...\n\nunique(md$Quali)\n\n[1] \"E\" \"A\" \"B\" \"C\"\n\nmd$Quali=as.factor(md$Quali)# Erklärungsvariable muss als Faktor deklariert sein\nlevels(md$Quali)\n\n[1] \"A\" \"B\" \"C\" \"E\"\n\n\n\n\nDaten plotten (Ausreißer, Eingabefehler, Varianzhomogenität visuell überprüfen)\n\nggplot(md, aes(x=Quali, y=Prot)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.25, height=0, shape=1)+\n  stat_summary(fun = \"mean\", colour = \"red\", size = 2, geom = \"point\")"
  },
  {
    "objectID": "Themen/04/04_Anova.html#modell-formulieren",
    "href": "Themen/04/04_Anova.html#modell-formulieren",
    "title": "ANOVA",
    "section": "Modell formulieren",
    "text": "Modell formulieren\nWichtig ist, dass die Abhängige kontinuierlich und die Erklärungsvariable ein Faktor ist.\n\nmod&lt;-lm(Prot ~ Quali, data=md) # Prot ist die Abhängige, Quali die Erklärungsvariable\nanova(mod)\n\nAnalysis of Variance Table\n\nResponse: Prot\n          Df Sum Sq Mean Sq F value   Pr(&gt;F)   \nQuali      3 35.666 11.8888  5.0814 0.006198 **\nResiduals 28 65.511  2.3397                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nQuali hat einen signifikanten Effekt auf den Proteingehalt."
  },
  {
    "objectID": "Themen/04/04_Anova.html#modellinterpretation",
    "href": "Themen/04/04_Anova.html#modellinterpretation",
    "title": "ANOVA",
    "section": "Modellinterpretation",
    "text": "Modellinterpretation\n\nsummary(mod) \n\n\nCall:\nlm(formula = Prot ~ Quali, data = md)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.1099 -0.9705  0.2110  0.9566  2.5819 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  13.2728     0.5408  24.543   &lt;2e-16 ***\nQualiB       -1.0279     0.7648  -1.344    0.190    \nQualiC       -1.5594     0.7648  -2.039    0.051 .  \nQualiE        1.2036     0.7648   1.574    0.127    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.53 on 28 degrees of freedom\nMultiple R-squared:  0.3525,    Adjusted R-squared:  0.2831 \nF-statistic: 5.081 on 3 and 28 DF,  p-value: 0.006198\n\n\n\nR² ist 35.3 %. Adjusted R² ist 28.3 %.\nHinter dem Intercept verbirgt sich das erste Level von Quali, i.e. A. A hat demnach einen geschätzten mittleren Proteingehalt von 13.3.\nUm den geschätzten mittleren Proteingehalt für B zu ermitteln, müssen wir Intercept + Estimate QualiB rechnen, d.h. 13.3 -1 = 12.2\nUm den geschätzten mittleren Proteingehalt für C zu ermitteln, müssen wir Intercept + Estimate QualiC rechnen, d.h. 13.3 -1.6 = 11.7\nund für E 13.3 + 1.2 = 14.5\n\n\nalternative Funktion aov\n… kommt zu den gleichen Ergebnissen und ist hier nur der Vollständigkeit halber erwähnt.\n\nmod.a&lt;-aov(Prot ~ Quali, data=md) # \nsummary(mod.a)\n\n            Df Sum Sq Mean Sq F value Pr(&gt;F)   \nQuali        3  35.67   11.89   5.081 0.0062 **\nResiduals   28  65.51    2.34                  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nsummary.lm(mod.a)\n\n\nCall:\naov(formula = Prot ~ Quali, data = md)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.1099 -0.9705  0.2110  0.9566  2.5819 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  13.2728     0.5408  24.543   &lt;2e-16 ***\nQualiB       -1.0279     0.7648  -1.344    0.190    \nQualiC       -1.5594     0.7648  -2.039    0.051 .  \nQualiE        1.2036     0.7648   1.574    0.127    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.53 on 28 degrees of freedom\nMultiple R-squared:  0.3525,    Adjusted R-squared:  0.2831 \nF-statistic: 5.081 on 3 and 28 DF,  p-value: 0.006198"
  },
  {
    "objectID": "Themen/04/04_Anova.html#modelldiagnostik",
    "href": "Themen/04/04_Anova.html#modelldiagnostik",
    "title": "ANOVA",
    "section": "Modelldiagnostik",
    "text": "Modelldiagnostik\nWir überprüfen die Annahmen der ANOVA visuell auf:\n\nannähernde Normalverteilung der Fehler (i.e. Residuen)\nVarianzhomogenität\n\nIch nutze hierfür die library(DHARMa).\nhttps://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html\n\nlibrary(DHARMa)\n\nThis is DHARMa 0.4.6. For overview type '?DHARMa'. For recent changes, type news(package = 'DHARMa')\n\nsimulationOutput &lt;- simulateResiduals(fittedModel = mod, plot = F)\nplot(simulationOutput)\n\n\n\n\n\nDie erste Grafik zeigt einen QQ-Plot der standardisierten Residuen und sagt uns etwas über die Normalverteilung der Residuen aus. Verlaufen die Punkte in etwa auf der Winkelhalbierenden (die rote Linie), dann ist alles ok. Außerdem werden uns p-Werte für den KS-Test (Kolmogorov-Smirnov-Test auf Normalverteilung), ein Dispersion- und Ausreißertest angezeigt.\nDie zweite Grafik plottet die Residuen gegen die Fitted Values. Wir wollen hier sehen, dass die Streuung um die Null sowohl bei hohen als auch bei niedrigen Werten in etwa gleich ist (Varianzhomogenität). Hier scheint ein leichter Trend vorzuliegen (ist aber m.E. noch ok). Der Plot ist auch hilfreich zum Identifizieren von auffälligen Stichproben. Diese werden als rote Sternchen abgebildet (müssen aber noch nicht zwingend als Ausreißer bezeichnet werden).\nUm die Varianzhomogenität zwischen den Gruppen zu prüfen, sollten wir die Residuen gegen die Erklärungsvariablen plotten.\n\n\nplotResiduals(simulationOutput, form = md$Quali)\n\n\n\n\nSolange alle Tests nicht signifikant sind (und keine roten Linien oder Boxen angezeigt werden), ist alles (mehr oder weniger) gut. ABER es sei angemerkt, dass die Teststärke (Power) der Tests von der Anzahl der Beobachtungen abhängt. Je mehr Beobachtungen wir haben, umso höher ist die Power des Tests. Damit werden häufig signifikante Unterschiede z.B. der Varianzen bei großem Stichprobenumfang beobachtet, obwohl diese praktisch nicht relevant sind. Außerdem werden häufig keine signifikanten Unterschiede bei kleinem Stichprobenumfang beobachtet, obwohl gravierende Unterschiede vorhanden sind.\nDie visuelle Modelldiagnostik wird daher häufig als wichtiger angesehen als die p-Wert-basierten Tests auf Normalverteilung und Varianzhomogenität (Cochran, Bartlett und Levenes Test).\n\n#Tests zur Varianzhomogenität\nvar.test(md$Prot[md$Quali==\"E\"], md$Prot[md$Quali==\"B\"] )\n\n\n    F test to compare two variances\n\ndata:  md$Prot[md$Quali == \"E\"] and md$Prot[md$Quali == \"B\"]\nF = 0.6686, num df = 7, denom df = 7, p-value = 0.6085\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.1338567 3.3396057\nsample estimates:\nratio of variances \n         0.6686019 \n\nbartlett.test(Prot ~ Quali, data=md)\n\n\n    Bartlett test of homogeneity of variances\n\ndata:  Prot by Quali\nBartlett's K-squared = 1.0564, df = 3, p-value = 0.7876\n\nlibrary(car)\nleveneTest(Prot ~ Quali, data=md) \n\nLevene's Test for Homogeneity of Variance (center = median)\n      Df F value Pr(&gt;F)\ngroup  3  0.3349 0.8002\n      28               \n\nlibrary(outliers)\ncochran.test(Prot ~ Quali, data=md)\n\n\n    Cochran test for outlying variance\n\ndata:  Prot ~ Quali\nC = 0.36079, df = 8, k = 4, p-value = 0.6601\nalternative hypothesis: Group C has outlying variance\nsample estimates:\n       A        B        C        E \n1.805174 2.503336 3.376528 1.673735 \n\n\nIn unserem Beispiel ist alles ok. Sowohl visuell als auch nach Aussage der Tests.\n\nHier ein Beispiel für Varianzheterogenität mit veränderten Daten.\n\nmd$Prot2= md$Prot\nset.seed(1309)\nmd$Prot2[md$Quali==\"E\"] =rnorm(8, 14.5, 13)\nggplot(md, aes(x=Quali, y=Prot2)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.25, height=0, shape=1)+\n  stat_summary(fun = \"mean\", colour = \"red\", size = 2, geom = \"point\") \n\n\n\n\n\nmod2&lt;-lm(Prot2 ~ Quali, data=md)\nsimulationOutput &lt;- simulateResiduals(fittedModel = mod2, plot = F)\nplot(simulationOutput)\n\n\n\nplotResiduals(simulationOutput, form = md$Quali)\n\n\n\n\nDie Residuen weisen eine größere Streuung auf mit größer werdenden fitted values. Um dem zu entgegnen könnte man die Analyse mit transformieren Daten durchführen oder besser einen Funktion für die unterschiedliche Varianz in den Gruppen anpassen (dies ist mit der Funktion glmmTMB() und lme möglich)."
  },
  {
    "objectID": "Themen/04/04_Anova.html#post-hoc-test",
    "href": "Themen/04/04_Anova.html#post-hoc-test",
    "title": "ANOVA",
    "section": "Post-hoc Test",
    "text": "Post-hoc Test\nDie ANOVA zeigte uns einen signifikanten Effekt von Quali auf Prot, jedoch wissen wir nicht, welche Weizenqualitätsklassen sich voneinander unterscheiden. Bei Faktoren mit mehr als 2 Ausprägungen wird daher ein Post-hoc Test durchgeführt. Dieser korrigiert die Irrtumswahrscheinlichkeit um die Anzahl der Vergleiche, da man bei z.B. 100 Ausprägungen, schon per Zufall 5 signifikante Unterschiede aufweisen können.\n\nBespiel für multiples Testen ohne und mit Adjustierung des p-Wertes\n\npairwise.t.test(md$Prot, md$Quali, p.adj = \"none\") # p-Werte werden nicht korrigiert, nicht gut! \n\n\n    Pairwise comparisons using t tests with pooled SD \n\ndata:  md$Prot and md$Quali \n\n  A      B      C     \nB 0.1897 -      -     \nC 0.0510 0.4928 -     \nE 0.1268 0.0069 0.0012\n\nP value adjustment method: none \n\n# Bonferroni-Korrektur (Bonferroni multipliziert p mit der Anzahl Tests, sehr konservativ)\npairwise.t.test(md$Prot, md$Quali, p.adj = \"bonferroni\") # besser\n\n\n    Pairwise comparisons using t tests with pooled SD \n\ndata:  md$Prot and md$Quali \n\n  A     B     C    \nB 1.000 -     -    \nC 0.306 1.000 -    \nE 0.761 0.041 0.007\n\nP value adjustment method: bonferroni \n\n\n\n\nPost-hoc Test: package emmeans\nDie library(emmeans) mit der Funktion emmeans() bietet eine Vielzahl an Möglichkeiten um einen Post-hoc Test am gefitteten Modell (hier die ANOVA) durchzuführen. Mit dem Argument method=\"pairwise\" kann man alle Behandlungen miteinander per Tukey-Test vergleichen, i.e. paarweise.\n\nlibrary(emmeans)\ncontrast(emmeans(mod, ~Quali), method=\"pairwise\")\n\n contrast estimate    SE df t.ratio p.value\n A - B       1.028 0.765 28   1.344  0.5437\n A - C       1.559 0.765 28   2.039  0.1982\n A - E      -1.204 0.765 28  -1.574  0.4093\n B - C       0.532 0.765 28   0.695  0.8981\n B - E      -2.231 0.765 28  -2.918  0.0328\n C - E      -2.763 0.765 28  -3.613  0.0061\n\nP value adjustment: tukey method for comparing a family of 4 estimates \n\n\nMit method=\"trt.vs.ctrl\" wird ein Dunnett-Test durchgeführt, der alle Behandlungen gegen eine Kontrolle testet. Die p-Werte werden automatisch um die Anzahl der Tests korrigiert.\n\ncontrast(emmeans(mod, ~Quali), method=\"trt.vs.ctrl\")\n\n contrast estimate    SE df t.ratio p.value\n B - A       -1.03 0.765 28  -1.344  0.4116\n C - A       -1.56 0.765 28  -2.039  0.1295\n E - A        1.20 0.765 28   1.574  0.2937\n\nP value adjustment: dunnettx method for 3 tests \n\n\nHier wird immer gegen die Qualität A gepürft, weil diese das erste Level der Variable Qualiist.\nMit dem Argument ref kann ich ein anderes Level wählen. Hier die E-Qualität.\n\ncontrast(emmeans(mod, ~Quali), method=\"trt.vs.ctrl\", ref=4)\n\n contrast estimate    SE df t.ratio p.value\n A - E       -1.20 0.765 28  -1.574  0.2937\n B - E       -2.23 0.765 28  -2.918  0.0190\n C - E       -2.76 0.765 28  -3.613  0.0033\n\nP value adjustment: dunnettx method for 3 tests \n\n\nAlternativ kann ich bereits im data.frame die Faktorenlevels entsprechend meiner Interpretation ändern und damit das Modell anpassen. (siehe dazu Reihenfolge ändern in Kap. Grafik)\nInteressant sind auch die Konfidenzintervalle. Wenn Konfidenzintervalle sich nicht überlappen, geht man in der Regel von signifikanten Unterschieden aus. Es kann auch sein, dass Konfidenzintervalle leicht überlappen, und trotzdem signifikante Unterschiede vorliegen. https://core.ac.uk/download/pdf/82702323.pdf Hier sollte man immer auf die p-Werte des Tests schauen.\n\nsummary(emmeans(mod, ~Quali)) #Konfidenzintervalle\n\n Quali emmean    SE df lower.CL upper.CL\n A       13.3 0.541 28     12.2     14.4\n B       12.2 0.541 28     11.1     13.4\n C       11.7 0.541 28     10.6     12.8\n E       14.5 0.541 28     13.4     15.6\n\nConfidence level used: 0.95 \n\nplot(emmeans(mod, ~Quali))\n\n\n\n\nUm Gruppenunterschiede leicht verständlich anzugeben bzw. zu visualisieren, kann das compact letter display genutzt werden. Hierfür benötigen wir die library(multcompView) und library(multcomp).\n\nlibrary(multcompView)\nlibrary(multcomp)\ncld(emmeans(mod, ~Quali), Letters=letters) # Compact letter display für Gruppenunterschiede \n\n Quali emmean    SE df lower.CL upper.CL .group\n C       11.7 0.541 28     10.6     12.8  a    \n B       12.2 0.541 28     11.1     13.4  a    \n A       13.3 0.541 28     12.2     14.4  ab   \n E       14.5 0.541 28     13.4     15.6   b   \n\nConfidence level used: 0.95 \nP value adjustment: tukey method for comparing a family of 4 estimates \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n\n\nGruppen, die keinen Buchstaben gemeinsam haben, sind im Mittelwert signifikant unterschiedlich. Qualitätsklasse E hat einen signifikant höheren Proteingehalt im Vergleich zu B und C, während E und A sich nicht signifikant unterscheiden."
  },
  {
    "objectID": "Themen/04/04_Anova.html#präsentation-der-ergebnisse",
    "href": "Themen/04/04_Anova.html#präsentation-der-ergebnisse",
    "title": "ANOVA",
    "section": "Präsentation der Ergebnisse",
    "text": "Präsentation der Ergebnisse\nSo könnte man die Daten und die Ergebnisse des Modells präsentieren. Ich speichere das Konfidenzintervall als Objekt CI und plotte es dann in den jittered Boxplot. Das Einzeichnen der Buchstaben muss nicht sein. Der Vollständigkeit halber soll es hier aber gezeigt werden.\n\nCIs=cld(emmeans(mod, ~Quali), sort = FALSE, Letters=letters)\nCIs$.group # hier sind noch Leerzeichen enthalten, die die Zentrierung der Buchstaben erschwert\n\n[1] \" ab\" \" a \" \" a \" \"  b\"\n\nCIs$.group =gsub(\" \", \"\", CIs$.group, fixed = TRUE)# entfernen der Leerzeichen\nCIs$.group # besser\n\n[1] \"ab\" \"a\"  \"a\"  \"b\" \n\nstr(CIs)\n\nClasses 'summary_emm' and 'data.frame': 4 obs. of  7 variables:\n $ Quali   : Factor w/ 4 levels \"A\",\"B\",\"C\",\"E\": 1 2 3 4\n $ emmean  : num  13.3 12.2 11.7 14.5\n $ SE      : num  0.541 0.541 0.541 0.541\n $ df      : num  28 28 28 28\n $ lower.CL: num  12.2 11.1 10.6 13.4\n $ upper.CL: num  14.4 13.4 12.8 15.6\n $ .group  : chr  \"ab\" \"a\" \"a\" \"b\"\n - attr(*, \"estName\")= chr \"emmean\"\n - attr(*, \"clNames\")= chr [1:2] \"lower.CL\" \"upper.CL\"\n - attr(*, \"pri.vars\")= chr \"Quali\"\n - attr(*, \"adjust\")= chr \"none\"\n - attr(*, \"side\")= num 0\n - attr(*, \"delta\")= num 0\n - attr(*, \"type\")= chr \"link\"\n - attr(*, \"mesg\")= chr [1:4] \"Confidence level used: 0.95\" \"P value adjustment: tukey method for comparing a family of 4 estimates\" \"significance level used: alpha = 0.05\" \"NOTE: If two or more means share the same grouping symbol,\\n      then we cannot show them to be different.\\n  \"| __truncated__\n\nggplot(md, aes(x=Quali, y=Prot)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot(outlier.shape=NA, width = 0.6) +\n  geom_jitter(width=0.25, height=0, shape=1)+\n  geom_point(data=CIs, aes(y=emmean), \n             shape=16,  size=2, col=2, \n             position = position_nudge(x = 0.4))+\n  geom_errorbar(data=CIs, aes(y=emmean, ymin=lower.CL, ymax=upper.CL), \n                width=0.1, col=2, position = position_nudge(x = 0.4))+\n  geom_text(data=CIs, aes(y = 20, label =.group))+\n  theme_bw() \n\n\n\n\nIm Text sollte man erwähnen, dass\n\nQuali einen signifikanten Einfluss auf Prot hat. Nutze die Funktion anova(mod) und gibt den p-Wert zusammen mit den degrees of freedom und F-Wert an.\nder Post-hoc Test gezeigt hat, dass E mit im Mittel 14.5 % einen signifikant höheren Proteingehalt hatte als B und C mit 12.2 % und 11.7 % , während E und A sich nicht unterscheiden. Die Proteingehalte von A, B und C unterscheiden sich nicht signifikant (p&gt;0.05). Hierzu nutzt du die Funktion contrast(emmeans(mod, c(\"Quali\")), method=\"pairwise\").\ndas R² des Modells 35.3 beträgt. summary(mod)$r.sq\ndie Modellannahmen für die ANOVA (Varianzhomogenität und annähernde Normalverteilung der Residuen) visuell mit dem Paket DHARMa überprüft wurden.\n\n\nadd on: Faktorlevels in Grafik umsortieren\nSchöner wäre es, die Qualitäten in absteigender Reihenfolge darzustellen. E steht für Elite und ist die beste Qualität.\n\nlibrary(forcats)\nmd %&gt;% \nggplot(aes(x=fct_relevel(Quali, \"E\"), y=Prot)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot(outlier.shape=NA, width = 0.6) +\n  geom_jitter(width=0.25, height=0, shape=1)+\n  geom_point(data=CIs, aes(y=emmean), \n           shape=16,  size=2, col=2, \n             position = position_nudge(x = 0.4))+\n  geom_errorbar(data=CIs, aes(y=emmean, ymin=lower.CL, ymax=upper.CL), \n                width=0.1, col=2, position = position_nudge(x = 0.4))+\n  geom_text(data=CIs, aes(y = 20, label =.group))+\n  theme_bw()\n\n\n\n\noder in aufsteigender Reihenfolge, basierend auf den Messwerten.\n\nCIs$Prot=CIs$emmean\nmd %&gt;% \nggplot(aes(x=fct_reorder(Quali, Prot), y=Prot)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot(outlier.shape=NA, width = 0.6) +\n  geom_jitter(width=0.25, height=0, shape=1)+\n  geom_point(data=CIs, aes(y=emmean), \n           shape=16,  size=2, col=2, \n             position = position_nudge(x = 0.4))+\n  geom_errorbar(data=CIs, aes(y=emmean, ymin=lower.CL, ymax=upper.CL), \n                width=0.1, col=2, position = position_nudge(x = 0.4))+\n  geom_text(data=CIs, aes(y = 20, label =.group))+\n  theme_bw()"
  },
  {
    "objectID": "Themen/04/04_Anova.html#übung-4",
    "href": "Themen/04/04_Anova.html#übung-4",
    "title": "ANOVA",
    "section": "Übung 4",
    "text": "Übung 4\nIn einem Gefäßversuch wurde die pflanzenliche Biomasse (BM) in den 4 Düngemittelvarianten (DM: Kontrolle, Düngemittel A, B und C) an jeweils 10 Proben gemessen.\n\nImportiere bitte die Daten Gefaessversuch.xlsx in R und mach Dich mit dem Datensatz vertraut.\nUnterscheidet sich die Biomasse zwischen den Varianten?\nSind die Voraussetzung für eine ANOVA gegeben? Prüfe die Residuen.\n\nEnde Übung 4"
  },
  {
    "objectID": "Themen/03/03_Graph.html#x-achsenlevels",
    "href": "Themen/03/03_Graph.html#x-achsenlevels",
    "title": "Grafische Darstellungen",
    "section": "x-Achsenlevels",
    "text": "x-Achsenlevels\nIn diesem Beispiel ist die Beschriftung der x-Achsenlevels sehr lang. Mit \\n können wir einen Zeilenumbruch erzeugen:\n\nggplot(data=pot, aes(x=method, y=weight)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot() +\n  facet_grid(~variety)+\n  scale_x_discrete(labels =c(\"aero-\\nponic\", \"bed\", \"hydro-\\nponic\", \"pot\"))\n\n\n\n\noder wir drehen die X-Achsenbeschriftungslevels um 45 Grad.\n\nggplot(data=pot, aes(x=method, y=weight)) +\n  stat_boxplot(geom =\"errorbar\", width = 0.5)+\n  geom_boxplot() +\n  facet_grid(~variety)+\n  scale_x_discrete(labels =c(\"aeronponic\", \"bed\", \"hydronponic\", \"pot\"))+\n  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))"
  },
  {
    "objectID": "Themen/05/05_Regression.html",
    "href": "Themen/05/05_Regression.html",
    "title": "Regression",
    "section": "",
    "text": "library(ggplot2)\nlibrary(dplyr)\nlibrary(gridExtra)\nlibrary(ggpubr)\nlibrary(ggfortify)\nlibrary(DHARMa)\nLineare Regression\nAnnahmen:\nmod.Bsp1=lm(yn~x)\nsimulationOutput &lt;- simulateResiduals(fittedModel = mod.Bsp1, plot = F)\nplot(simulationOutput)\n\n\n\nmod.Bsp2=lm(yh~x)\nsimulationOutput &lt;- simulateResiduals(fittedModel = mod.Bsp2, plot = F)\nplot(simulationOutput)\nNur für das erste Beispiel treffen die Annahmen für eine Regression zu. Im zweiten Beispiel tritt der Trompeteneffekt auf (Heteroskedastizität)."
  },
  {
    "objectID": "Themen/05/05_Regression.html#beispiel-trade-off-zwischen-ertrag-und-proteingehalt",
    "href": "Themen/05/05_Regression.html#beispiel-trade-off-zwischen-ertrag-und-proteingehalt",
    "title": "Regression",
    "section": "Beispiel Trade-off zwischen Ertrag und Proteingehalt",
    "text": "Beispiel Trade-off zwischen Ertrag und Proteingehalt\nBei gleicher N-Düngung beobachtet man im Weizen aufgrund unterschiedlicher Sorteneigenschaften häufig einen Trade-off zwischen Ertrag und Proteingehalt.\nFrage: Wie stark reduziert sich der Proteingehalt mit steigendem Ertrag?"
  },
  {
    "objectID": "Themen/05/05_Regression.html#daten-einlesen-kennenlernen-und-plotten",
    "href": "Themen/05/05_Regression.html#daten-einlesen-kennenlernen-und-plotten",
    "title": "Regression",
    "section": "Daten einlesen, kennenlernen und plotten",
    "text": "Daten einlesen, kennenlernen und plotten\n\nlibrary(openxlsx)\nreg&lt;-read.xlsx(\"Trade-off.xlsx\")\nstr(reg)\n\n'data.frame':   10 obs. of  2 variables:\n $ Ert : num  90.5 101.3 93.3 102 72 ...\n $ Prot: num  10.9 12.5 12.3 11.6 13.3 ...\n\nsummary(reg)\n\n      Ert              Prot      \n Min.   : 51.65   Min.   :10.51  \n 1st Qu.: 72.88   1st Qu.:11.73  \n Median : 90.70   Median :12.89  \n Mean   : 84.93   Mean   :13.12  \n 3rd Qu.: 99.30   3rd Qu.:14.07  \n Max.   :109.28   Max.   :16.80  \n\nggplot(reg, aes(x=Ert, y=Prot)) +\n  geom_point()"
  },
  {
    "objectID": "Themen/05/05_Regression.html#modell-formulieren",
    "href": "Themen/05/05_Regression.html#modell-formulieren",
    "title": "Regression",
    "section": "Modell formulieren",
    "text": "Modell formulieren\n\nmod&lt;-lm(Prot~Ert, data=reg)\nsummary(mod)\n\n\nCall:\nlm(formula = Prot ~ Ert, data = reg)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1.64733 -0.49234  0.00472  0.60021  1.54734 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 21.26794    1.55972  13.636 8.05e-07 ***\nErt         -0.09590    0.01798  -5.335 0.000699 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.008 on 8 degrees of freedom\nMultiple R-squared:  0.7806,    Adjusted R-squared:  0.7531 \nF-statistic: 28.46 on 1 and 8 DF,  p-value: 0.0006987\n\n\nMit jeder dt/ha steigendem Ertrag sinkt der Proteingehalt um -0.1 %. Das R² des Modells 78.1 beträgt."
  },
  {
    "objectID": "Themen/05/05_Regression.html#signifikanztest-der-modellparameter",
    "href": "Themen/05/05_Regression.html#signifikanztest-der-modellparameter",
    "title": "Regression",
    "section": "Signifikanztest der Modellparameter",
    "text": "Signifikanztest der Modellparameter\n\ndrop1(mod, test=\"F\")\n\nSingle term deletions\n\nModel:\nProt ~ Ert\n       Df Sum of Sq    RSS     AIC F value    Pr(&gt;F)    \n&lt;none&gt;               8.128  1.9277                      \nErt     1    28.914 37.043 15.0948  28.458 0.0006987 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nSignifikanter Zusammenhang zwischen Ertrag und Proteingehalt."
  },
  {
    "objectID": "Themen/05/05_Regression.html#modelldiagnostik",
    "href": "Themen/05/05_Regression.html#modelldiagnostik",
    "title": "Regression",
    "section": "Modelldiagnostik",
    "text": "Modelldiagnostik\n\nlibrary(DHARMa)\nsimulationOutput &lt;- simulateResiduals(fittedModel = mod, plot = F)\nplot(simulationOutput)\n\n\n\n\nAuch wenn es bei diesem kleinen Stichprobenumfang schwierig ist, diese Plots sicher zu interpretieren, sieht alles ganz ok aus.\n\nDie Residuen sind annähernd normalverteilt (Plot oben links).\nDie Residuen weisen im Plot oben rechts keinen Trompeteneffekt (Varianzheterogenität) auf.\nEs gibt keine auffälligen Muster in Residuen.\nEs gibt keine einflussreiche Punkte (keine roten Sternchen in der Abb. rechts).\n\nDas Paket ggfortify gibt und noch zwei weitere Plots zur Cook’s Distance und Leverage aus. Hat eine Stichprobe eine hohe Leverage (i.e. Hebelwirkung, extremer Wert in x) und gleichzeitig ein großes Residuum (große Differenz zwischen beobachtetem und erwartetem Wert), dann spricht man von einem einflussreichem Punkt, der evtl. ein Ausreißer ist und durch eine hohe Cook’s Distance (&gt; 1 oder 0,5) gekennzeichnet ist.\nEntsprechend kann man auf diese Werte nochmal genauer schauen (i.e. den Wert auf Eingabefehler überprüfen) und ggfls. das Model ohne Ausreißer rechnen und die “neuen” Modellparameter mit den “alten” vergleichen und damit die Robustheit der Ergebnisse überprüfen.\n\nlibrary(ggfortify)\nautoplot(mod, which =c(4,6), ncol = 2, label.size = 3)"
  },
  {
    "objectID": "Themen/05/05_Regression.html#modellinterpretation",
    "href": "Themen/05/05_Regression.html#modellinterpretation",
    "title": "Regression",
    "section": "Modellinterpretation",
    "text": "Modellinterpretation\nDie predict-Funktion rechnet uns die Erwartungswerte basierend auf den Modellkoeffizienten aus. Gibt man kein weiteres Argument in die predict-Funktion, dann werden die Originaldaten zur Vorhersage genutzt.\n\npredict(mod) \n\n       1        2        3        4        5        6        7        8 \n12.59231 11.55265 12.32326 11.48316 14.36743 16.31497 15.24944 14.01335 \n       9       10 \n12.54665 10.78760 \n\nreg$Ert\n\n [1]  90.46327 101.30412  93.26876 102.02872  71.95367  51.64602  62.75668\n [8]  75.64570  90.93937 109.28159\n\n\nBei einem Ertrag von 0 schätzt unser Modell ein Proteingehalt von 21.27 %., bei einem Ertrag von 50 dt/ha schätzt es ein Proteingehalt von 16.5, bei einem Ertrag von 100 schätzt es ein Proteingehalt von 11.7.\nWir können uns nun fragen, wie hoch der Proteingehalt bei einem Ertrag von 80 dt/ha ist. Hierzu müssen wir die geschätzten Koeffizienten (coef(mod)) in die Modellgleichung (y = a + b*x) einsetzen, wobei a der Intercept, b der Koeffizient für Ert und x der Ertrag ist:\n\npredict(mod, newdata=data.frame(Ert=80))\n\n       1 \n13.59576 \n\n\nJetzt fehlt nur noch eine Abbildung zum Zusammenhang zwischen Wachstum und Ertrag.\nGanz schnell und einfach geht es mit dem Package effects.\n\nlibrary(effects)\nplot(allEffects(mod))\n\n\n\nplot(Effect(c(\"Ert\"), mod, partial.residuals=TRUE))\n\n\n\n\nDie blaue Linie zeigt uns den fit (also die Regressionslinie) an, die orangefarbene Linie ist ein fit durch die Residuen und sollte entlang der blauen Linie laufen und keine Kurvatur aufweisen.\nEine weitere Alternative für die Abbildung der Originalwerte zusammen mit den Vorhersagewerten und Konfidenzintervalle des Modells bietet die library(effects).\n\nef=allEffects(mod, xlevels=100)\nef1=as.data.frame(ef[[1]])\nhead(ef1)\n\n    Ert      fit        se    lower    upper\n1 51.65 16.31459 0.6778851 14.75139 17.87780\n2 52.23 16.25897 0.6687008 14.71694 17.80100\n3 52.81 16.20335 0.6595535 14.68241 17.72428\n4 53.39 16.14772 0.6504446 14.64779 17.64765\n5 53.97 16.09210 0.6413759 14.61308 17.57111\n6 54.56 16.03552 0.6321938 14.57767 17.49336\n\ntail(ef1)\n\n      Ert      fit        se    lower    upper\n95  106.4 11.06395 0.5005978 9.909565 12.21833\n96  107.0 11.00640 0.5089613 9.832737 12.18007\n97  107.5 10.95845 0.5159996 9.768556 12.14835\n98  108.1 10.90091 0.5245242 9.691357 12.11047\n99  108.7 10.84337 0.5331307 9.613969 12.07277\n100 109.3 10.78583 0.5418153 9.536401 12.03526\n\n\nDurch das Argument xlevels=100 werden 100 Einträge für die Erklärungsvariablen im beobachteten Werteberich erzeugt. Die Spalte fit zeigt die fitted values (Vorhersagewerte) und in lower und upper sind die Grenzen des Konfidenzintervalls aufgeführt.\nNun plotten wir die Originalwerte und zeichnen dann die Daten aus ef1 mit den Funktionen geom_line() und geom_ribbon() ein.\n\nggplot(reg, aes(x=Ert, y=Prot)) +\n  geom_point()+\n  geom_line(data = ef1, aes(x = Ert, y = fit))+\n  geom_ribbon(data = ef1, aes(x = Ert, y = NULL, ymin =lower, ymax = upper), alpha = 0.4)\n\n\n\n\nBei einer einfachen Regression kann man die Regressionslinie mit der Funktion geom_smooth(method=lm) einzeichnen.\n\nggplot(reg, aes(x=Ert, y=Prot)) +\n  geom_point()+\n  geom_smooth(method=lm)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\noder geom_abline(intercept = 21.26794, slope = -0.09590221)\n\nggplot(reg, aes(x=Ert, y=Prot)) +\n  geom_point()+\n  geom_abline(intercept= 21.26794, slope=-0.09590221)\n\n\n\n# oder so\nggplot(reg, aes(x=Ert, y=Prot)) +\n  geom_point()+\n  geom_abline(intercept=coef(mod)[1], slope=coef(mod)[2])\n\n\n\n\nAlternativ, aber etwas komplizierter, geht es auch so:\nUm die Regressionslinie des Modells in einen Plot “per Hand” einzuzeichnen, erstellen wir einen Testdatensatz, der alle Erklärungsvariablen des Modells in einem realistischen Wertebereich (Minimum bis Maximum) enthält. In diesem Beispiel ist das sehr einfach, da Ert die einzige Erklärungsvariable ist.\nWir benennen den Testdatensatz td und nutzen die predict-Funktion mit dem Argument newdata=td um die Erwartungswerte td$p zu berechnen.\n\nrange(reg$Ert)\n\n[1]  51.64602 109.28159\n\n#Testdatensatz mit Erklärungsvariablen (Wertebereich und Variablenname) erstellen \ntd&lt;-data.frame(Ert=seq(from = 50, to =110, by = 5))\n\ntd\n\n   Ert\n1   50\n2   55\n3   60\n4   65\n5   70\n6   75\n7   80\n8   85\n9   90\n10  95\n11 100\n12 105\n13 110\n\n#Predict-Funktion für neu erstellten Datensatz nutzen\ntd$p&lt;-predict(mod, newdata=td)\ntd\n\n   Ert        p\n1   50 16.47283\n2   55 15.99332\n3   60 15.51381\n4   65 15.03430\n5   70 14.55479\n6   75 14.07528\n7   80 13.59576\n8   85 13.11625\n9   90 12.63674\n10  95 12.15723\n11 100 11.67772\n12 105 11.19821\n13 110 10.71870\n\ntd&lt;-data.frame(td, predict(mod, newdata=td, interval = \"confidence\"))\ntd\n\n   Ert        p      fit       lwr      upr\n1   50 16.47283 16.47283 14.848937 18.09672\n2   55 15.99332 15.99332 14.551201 17.43544\n3   60 15.51381 15.51381 14.245615 16.78200\n4   65 15.03430 15.03430 13.928471 16.14012\n5   70 14.55479 14.55479 13.593891 15.51568\n6   75 14.07528 14.07528 13.232828 14.91772\n7   80 13.59576 13.59576 12.832845 14.35868\n8   85 13.11625 13.11625 12.381199 13.85131\n9   90 12.63674 12.63674 11.872220 13.40126\n10  95 12.15723 12.15723 11.311883 13.00258\n11 100 11.67772 11.67772 10.713011 12.64243\n12 105 11.19821 11.19821 10.087965 12.30845\n13 110 10.71870 10.71870  9.445689 11.99171\n\nstr(td)\n\n'data.frame':   13 obs. of  5 variables:\n $ Ert: num  50 55 60 65 70 75 80 85 90 95 ...\n $ p  : num  16.5 16 15.5 15 14.6 ...\n $ fit: num  16.5 16 15.5 15 14.6 ...\n $ lwr: num  14.8 14.6 14.2 13.9 13.6 ...\n $ upr: num  18.1 17.4 16.8 16.1 15.5 ...\n\n\nJetzt plotten wir die Originaldaten und zeichnen\n\ndie Regressionslinie durch die geom_line()-Funktion der vorhergesagten Werte td$fit und\ndas Konfidenzintervall durch die geom_ribbon-Funktion der vorhergesagten Werte td$lwr und td$upr ein.\n\n\nggplot(reg, aes(x=Ert, y=Prot)) +\n  geom_point()+\n  geom_line(data = td, aes(x = Ert, y = fit))+\n  geom_ribbon(data = td, aes(x = Ert, y = NULL, ymin = lwr, ymax = upr), alpha = 0.4)"
  },
  {
    "objectID": "Themen/05/05_Regression.html#polynomiale-regression-quadratischer-term",
    "href": "Themen/05/05_Regression.html#polynomiale-regression-quadratischer-term",
    "title": "Regression",
    "section": "Polynomiale Regression: Quadratischer Term",
    "text": "Polynomiale Regression: Quadratischer Term\nMit einer linearen Regression können auch “nicht-lineare” Zusammenhänge modelliert werden.\n\n\n\n\n\nWenn die Daten einen nicht-linearen Trend aufweisen, wir aber nur einen linearen Term modellieren (Abbildung unten links), zeigen die Residuen ein Muster, i.e. eine Kurvatur, auf (Abbildung unten rechts).\n\n\n\n\n\n\nset.seed(123)\ndf=data.frame(y3=y3+runif(length(y3),0,5), x)\nmod=lm(y3~x, df)\nggplot(data=df, aes(y=y3, x=x))+\n  geom_point()+geom_smooth(method = lm)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\nsimulationOutput &lt;- simulateResiduals(fittedModel = mod, plot = F)\nplot(simulationOutput)\n\n\n\n\nWir können diesen Zusammenhang modellieren, indem wir einen quadratischen Term in das lineare Modell nehmen.\nmod&lt;-lm(Abhängige~poly(Erklärungsvariable, 2), data=md)\noder\nmod&lt;-lm(Abhängige~Erklärungsvariable+I(Erklärungsvariable^2), data=md)\nDas I (Großbuchstabe i) steht für “as is”."
  },
  {
    "objectID": "Themen/05/05_Regression.html#übung-5",
    "href": "Themen/05/05_Regression.html#übung-5",
    "title": "Regression",
    "section": "Übung 5",
    "text": "Übung 5\n\nImportiere die Daten NDuenger.xlsx und mach dich mit den Daten vertraut.\nFühre eine Regression durch, um den Einfluss der N-Düngung auf den Ertrag zu modellieren. Was ist die Abhängige (y), was die Erklärungsvariable (x)?\nStimmen die Annahmen für eine lineare Regression?\nWie hoch ist laut Modell der zu erwartende Ertrag bei 120 kg N?\nPlotte die Regressionslinie des Modells/der Modelle.\n\nExtraaufgabe:\n\nExtrapoliere die Vorhersage des Modells für eine N-Düngung von 250 kg.\n\nEnde Übung 5"
  }
]